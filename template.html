<!DOCTYPE html>
<html><head>
<meta charset="utf-8"/>
<link rel="apple-touch-icon" href="favicon.png"/>
<link rel="shortcut icon" href="favicon.png"/>
<link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto" />
<meta name="viewport" content="width=device-width"/>
<meta name="viewport" content="initial-scale=1.0"/>
<meta name="theme-color" media="(prefers-color-scheme: dark)"  content="#222">
<title>[[TITLE]]</title>
<style>
:root{
    --content-size:100%;
    --word-pointer:pointer;
    --widget-height:62px;
}

html,
body{
    height:100%;
    margin:0;
    padding:0;
    border:0;
    background-color:#333;
    color:#ccc;
    font-family:"Roboto",sans-serif;
    font-size:12pt;
    box-sizing:border-box;
}

.overlay{
    position:fixed;
    background-color:rgba(0,0,0,.25);
    top:0;
    left:0;
    width:100%;
    height:100%;
}

.content{
    font-size:var(--content-size);
    padding:10px;
    padding-top:60px;
    padding-bottom:30px;
}

.cols{
    display:flex;
    flex-flow:column;
}

.rows{
    display:flex;
    flex-flow:row;
}

@keyframes fade{
    0%{opacity:0;transform:translateX(4em);}
    100%{opacity:1;transform:translateX(0em);}
}

@-webkit-keyframes fade{
    0%{opacity:0;transform:translateX(4em);}
    100%{opacity:1;transform:translateX(0em);}
}

@keyframes unfade{
    0%{opacity:1;transform:translateX(0em);}
    100%{opacity:0;transform:translateX(4em);}
}

@-webkit-keyframes unfade{
    0%{opacity:1;transform:translateX(0em);}
    100%{opacity:0;transform:translateX(4em);}
}

.hideDrop{
    -webkit-animation:unfade 0.25s;
    animation:unfade 0.25s;
}

.showDrop{
    -webkit-animation:fade 0.25s;
    animation:fade 0.25s;
}

.dropdown{
    position:fixed;
    top:calc(var(--widget-height) - 10px);
    width:10em;
    left:calc(100% - 10em);
    align-items:center;
    padding:10px;
    line-height:150%;
    background-color:#222;
    box-shadow:0 1px 2px hsla(0,0%,0%,0.1),0 1px 4px hsla(0,0%,0%,0.1),0 2px 8px hsla(0,0%,0%,0.1);
}

.util{
    cursor:pointer;
    color:#bbf;
    overflow:hidden;
    width:100%;
    display:block;
}

.util:hover{
    background-color:#559;
}

.header{
    align-items:center;
    background-color:#222;
    position:fixed;
    box-sizing:border-box;
    top:-10px;
    padding-top:10px;
    left:0;
    width:100%;
    height:var(--widget-height);
    box-shadow:0 1px 2px hsla(0,0%,0%,0.1),0 1px 4px hsla(0,0%,0%,0.1),0 2px 8px hsla(0,0%,0%,0.1);
}

.sel::before{
    content:"\2022\00a0";
}

.nosel::before{
    content:"\00a0\00a0";
}

.fill{
    flex:100%;
}

.fillToEdge{
    height:100%;
    width:100%;
}

span.current{
    color:#fff;
    background:#833;
    cursor:var(--word-pointer);
    scroll-margin:calc(1.5em + var(--widget-height)) 0 2.5em 0;
}

span.left{
    margin-left:-5px;
    padding-left:5px;
    border-radius:3px 0 0 3px;
}

span.right{
    border-radius:0 3px 3px 0;
}

span.word{
    cursor:var(--word-pointer);
    scroll-margin:2.5em 0;
}

p{
    padding:4px 0;
    margin-left:2ch;
    text-indent:-2ch;
    margin-top:.1em;
    margin-bottom:.1em;
    line-height:1.3;
}

p.current{
    background-color:#444;
    box-shadow:4px 0 0 #444,-2ch 0 0 #444;
    border-radius:5px;
    scroll-margin:2.5em 0;
}

@media only screen and (max-width:600px){
    :root{
        --extra_height:1.3;
    }
    span.current{
        scroll-margin:calc(1.5em + (var(--widget-height) * var(--extra_height))) 0 2.5em 0;
    }
    .header{
        height:calc(var(--widget-height) * var(--extra_height));
    }
    .content{
        padding-top:calc(60px * var(--extra_height));
    }
    .playPause{
        transform:scale(1.9);
    }
    p{
        margin-left:0;
        text-indent:0;
    }
    p.current{
        box-shadow:4px 0 0 #444,-4px 0 0 #444;
    }
}
@media only screen and (min-width:700px){
    .content{
        width:600px;
        margin-left:calc((100% - 600px) / 2);
    }
    p{
        margin-left:0;
    }
}
.timecode{
    color:#aaa;
}

.speaker{
    color:#888;
}

.diff{
    font-style:italic;
}

.hidden{
    display:none;
}

.playPause{
    margin-left:1em;
    margin-right:1em;
    margin-bottom:5px;
    margin-top:5px;
    cursor:pointer;
}

.play .forPause{
    display:none;
}

.slider{
    appearance:none;
    height:15px;
    margin:10px;
    border-radius:5px; 
    outline:none;
    background:#444;
}

.slider::-webkit-slider-thumb{
    appearance:none;
    width:26px;
    height:26px;
    border-radius:50%;
    background:#bbf;
    cursor:pointer;
}

.slider::-moz-range-thumb{
    width:26px;
    height:26px;
    border-radius:50%;
    background:#bbf;
    cursor:pointer;
}

.link{
    cursor:pointer;
    margin:10px;
}

.leftpad{
    margin:10px;
}

input[type=button],input[type=submit],input[type=reset]{
    background-color:#444;
    border:none;
    color:#f8f8f2;
    padding:2pt 20pt;
    text-decoration:none;
    cursor:pointer;
    font-family:Menlo,Monaco,Consolas,monospace;
    font-size:12pt;
}

input[type="text"],input[type="number"],textarea{
    background-color:#000;
    color:#cec;
    font-family:Menlo,Monaco,Consolas,monospace;
    font-size:12pt;
    margin:3px;
    border-top-style:hidden;
    border-right-style:hidden;
    border-left-style:hidden;
    border-bottom-style:solid;
    border-bottom-width:1px;
    border-bottom-color:#a8a8f2;
    padding:2px;
}
</style>
<script>

const extraMove=()=>{};
const extraScript=()=>{};
const extraSetup=()=>{};
const meta={
    words:"[[WORDS_VAR]]",
    title:"[[TITLE_META]]",
    id:"[[WORD_ID]]",
    dur:"[[EXPECTED_DUR]]",
    src:"[[META_MP3_NAME]]"
};

/* --- Minify Start --- */
function getParam(name, decode) {
    let ret = urlQuery.get(name);
    if (ret !== null && decode) { ret = atob(ret); }
    return ret
}

let byTime = [];
let paras = [];
let parasReady = false;
let lastHighlighted = null;
let isUserMoving = false;
let scrollState = [-1, -1, -1];
let playerLeftToLoad = 3;
let playerIsPlaying = false;
let jumpOnClick = true;
let autoScroll = true;
let wakeLock = null;
let isInterrupted = false;
let player = null;
let requestWakeLock = null;
let urlQuery = new URLSearchParams(window.location.search);
let urlHash = window.location.hash;
let tickURL = getParam("tick_url", true);
let selfID = getParam("id");
let tickStatus = null;

function move(e) {
    if (!jumpOnClick) {
        return;
    }
    extraMove();
    if (e.srcElement !== undefined) {
        e = e.srcElement.at;
    }
    if (playerLeftToLoad == -1) {
        let paused = player.paused;
        if (!paused) {
            play();
        }
        player.currentTime = e;
        if (!paused) {
            play();
        }
        updateScrolls();
    } else {
        player.newTarget = e;
        if (player.paused) {
            play();
        }
    }
};

function movePara(prevPara) {
    let temp = null;
    if (temp === null && lastHighlighted !== null) {
        temp = prevPara ? lastHighlighted[0].para.previousSibling : lastHighlighted[lastHighlighted.length-1].para.nextSibling;
    }
    if (temp === null && parasReady) {
        temp = paras[0];
    }
    if (temp !== null) {
        temp = temp.childNodes;
        for (let i = 0; i < temp.length; i++) {
            if (temp[i].hasOwnProperty('at')) {
                player.currentTime = (temp[i].at + temp[i].at) / 2;
                return true;
            }
        }
    }
}

function moveWord(prevWord) {
    if (lastHighlighted === null) {
        let line = paras[0], temp = line.childNodes;
        for (let i = 0; i < temp.length; i++) {
            if (temp[i].hasOwnProperty('at')) {
                let word = temp[i];
                player.currentTime = (word.at + word.atEnd) / 2;
                break
            }
        }
    } else {
        player.currentTime = prevWord ? lastHighlighted[0].at - (1.0 * player.playbackRate) : lastHighlighted[lastHighlighted.length-1].atEnd + 0.1;
    }
}

document.addEventListener('keydown', e => {
    if (!e.altKey && !e.ctrlKey && !e.metaKey && !e.shiftKey) {
        if (document.getElementById("overlay").className === "overlay hidden") {
            if (e.code === 'Space') {
                e.preventDefault();
                play();
                return true;
            }

            if (new Set(['ArrowUp', 'ArrowDown']).has(e.code)) {
                e.preventDefault();
                movePara(e.code === 'ArrowUp');
                return true;
            }
            else if (new Set(['ArrowLeft', 'ArrowRight']).has(e.code)) {
                e.preventDefault();
                moveWord(e.code === 'ArrowLeft');
                return true;
            }
        } else {
            if (e.code === 'Escape') {
                hideDrop();
                return true;
            }
        }
    }
    if (e.key === 's' && !e.altKey && e.ctrlKey && !e.metaKey && !e.shiftKey) {
        e.preventDefault();
        showPos();
        return true;
    }
});

function pad(value, width=1, padChar='0') {
    value = Math.floor(value) + '';
    return value.length >= width ? value : new Array(width - value.length + 1).join(padChar) + value;
};

function getTick(at) {
    return pad(at / 3600) + ":" + pad((at % 3600) / 60, 2) + ":" + pad(at % 60, 2);
}

function play() {
    if (playerLeftToLoad >= 0) {
        playerLeftToLoad = 0;
        playerLoaded();
    }

    if (player.paused) {
        player.play();
    } else {
        player.pause();
    }
}

function posChange() {
    move(document.getElementById("pos").value / 10);
}

function posMoving() {
    isUserMoving = true;
}

function posMoved() {
    isUserMoving = false;
}

function bisect(target, handler, invert) {
    let start = 0, end = target.length - 1;
    let valid = null;
    while (start != end) {
        let mid = Math.floor((start + end) / 2);
        if (handler(target[mid])) {
            if (invert) {
                end = mid;
            } else {
                start = mid + 1;
            }
            valid = target[mid];
        } else {
            if (invert) {
                start = mid + 1;
            } else {
                end = mid;
            }
        }
    }
    if (handler(target[start])) {
        return target[start];
    } else {
        return valid;
    }
}

function updateScrolls() {
    if (!parasReady) {
        return;
    }

    let pos = document.getElementById("pos"), loc = pos.value / pos.max, 
        temp = [window.innerHeight, paras[paras.length - 1].getBoundingClientRect().bottom, loc];
    if (temp[0] == scrollState[0] && temp[1] == scrollState[1] && temp[2] == scrollState[2]) {
        return;
    }
    scrollState = temp;

    let pageStart = bisect(paras, e => e.getBoundingClientRect().bottom >= 50, true), 
        pageEnd = bisect(paras, e => e.getBoundingClientRect().top <= window.innerHeight, false);

    if (pageStart !== null && pageEnd !== null) {
        function calcPerc(e, invert) {
            let rect = e.getBoundingClientRect(), 
                perc = (invert ? (window.innerHeight - rect.top) : (rect.bottom - 50)) / (rect.bottom - rect.top);
            perc = perc < 0 ? 0 : (perc > 1 ? 1 : perc);
            if (invert) {
                return ((e.end * perc) + (e.start * (1 - perc)));
            } else {
                return ((e.start * perc) + (e.end * (1 - perc)));
            }
        }
        
        pageStart = calcPerc(pageStart, false) ;
        pageEnd = calcPerc(pageEnd, true) ;

        let done = '#555', togo = '#333', page = '#66a', view = 3;
        if (pageEnd <= loc) {
            view = 1;
        } else if (pageStart >= loc) {
            view = 2;
        }

        loc = `calc((100% - 26px) * ${loc} + 13px)`;
        pageStart = `calc((100% - 26px) * ${pageStart} + 13px)`;
        pageEnd = `calc((100% - 26px) * ${pageEnd} + 13px)`;
        let temp = '';
        if (view == 1) {
            temp = `,${done} 0% ${pageStart},${page} ${pageStart} ${pageEnd},${done} ${pageStart} ${loc},${togo} ${loc} 100%`;
        } else if (view == 2) {
            temp = `,${done} 0% ${loc},${togo} ${loc} ${pageStart},${page} ${pageStart} ${pageEnd},${togo} ${pageEnd} 100%`;
        } else {
            temp = `,${done} 0% ${pageStart},${page} ${pageStart} ${pageEnd},${togo} ${pageEnd} 100%`;
        }
        pos.style.background = 'linear-gradient(to right' + temp + ')';
    }
}

function posChanging(includeScrolls=true) {
    if (includeScrolls) {
        updateScrolls();
    }
    document.getElementById("posText").innerHTML = getTick(pos.value / 10) + '<br><font size="-1">' + ('-' + getTick((pos.max - pos.value) / 10)) + "</font>";
}

function hideDrop() {
    let drop = document.getElementById("dropdown");
    if (drop.className == "dropdown showDrop") {
        drop.className = "dropdown hideDrop";
    }
    let setpos = document.getElementById("setpos");
    if (setpos.className == "dropdown showDrop") {
        setpos.className = "dropdown hideDrop";
    }
    let overlay = document.getElementById("overlay");
    overlay.className = "overlay hidden";
}

function posSelected(e) {
    hideDrop();
    e.preventDefault = true;
    let newPos = document.getElementById('enteredPos').value;
    if (newPos.includes(":") || newPos.includes(".") || newPos.includes("-") || newPos.includes(",") || newPos.includes(" ")) {
        newPos = newPos.replace(/[,. -]/g, ":");
        newPos = newPos.split(":");
        if (newPos.length == 3 || newPos.length == 2) {
            let h = parseInt(newPos.length == 3 ? newPos[0] : '0'), 
                m = parseInt(newPos.length == 3 ? newPos[1] : newPos[0]), 
                s = parseInt(newPos.length == 3 ? newPos[2] : newPos[1]);
            if (h >= 0 && h <= 99 && m >= 0 && m <= 59 && s >= 0 && s <= 59) {
                let temp = h * 3600 + m * 60 + s;
                if (temp >= 0 && temp <= 43200) {
                    move(h * 3600 + m * 60 + s);
                }
            }
        }
    } else {
        let temp = parseFloat(newPos);
        if (temp >= 0 && temp <= 60) {
            move(temp * 60);
        } else if (temp > 60 && temp <= 43200) {
            move(temp);
        }
    }
    hideDrop();
    return false;
}

function showLinks() {
    let drop = document.getElementById("dropdown");
    if (!drop.hasOwnProperty('eventSetup')) {
        drop.eventSetup = true;
        drop.addEventListener('animationend', (e) => {
            if (drop.className == "dropdown hideDrop") {
                drop.className = "dropdown hideDrop hidden";
            }
        });
    }

    if (drop.className == "dropdown showDrop") {
        hideDrop();
    } else {
        drop.className = "dropdown showDrop";
        let overlay = document.getElementById("overlay");
        overlay.className = "overlay";
    }
}

function showPos() {
    let enteredPos = document.getElementById('enteredPos');
    enteredPos.value = getTick(player.currentTime);
    let setpos = document.getElementById("setpos");
    if (!setpos.hasOwnProperty('eventSetup')) {
        setpos.eventSetup = true;
        setpos.addEventListener('animationend', (e) => {
            if (setpos.className == "dropdown hideDrop") {
                setpos.className = "dropdown hideDrop hidden";
            }
        });
    }
    let drop = document.getElementById("dropdown");
    drop.className = "dropdown hideDrop hidden";

    setpos.className = "dropdown showDrop";
    let overlay = document.getElementById("overlay");
    overlay.className = "overlay";

    enteredPos.focus();
    enteredPos.select();
}

let clipboard = (function(window, document, navigator) {
    let textArea, copy;

    function isOS() {
        return navigator.userAgent.match(/ipad|iphone/i);
    }

    function createTextArea(text) {
        textArea = document.createElement('textArea');
        textArea.value = text;
        document.body.appendChild(textArea);
    }

    function selectText() {
        let range, selection;

        if (isOS()) {
            range = document.createRange();
            range.selectNodeContents(textArea);
            selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            textArea.setSelectionRange(0, 999999);
        } else {
            textArea.select();
        }
    }

    function copyToClipboard() {        
        document.execCommand('copy');
        document.body.removeChild(textArea);
    }

    copy = function(text) {
        createTextArea(text);
        selectText();
        copyToClipboard();
    };

    return {
        copy: copy
    };
})(window, document, navigator);

function getLink() {
    let uri = window.location.href.split("#")[0].split("?")[0] + "#" + Math.floor(player.currentTime * 10);
    clipboard.copy(uri);
    alert("Link copied to clipboard");
    hideDrop();
}

function onAutoScroll() {
    autoScroll = !autoScroll;
    document.getElementById('auto_scroll').className = (autoScroll ? "util sel" : "util nosel");
}

function onClickToJump() {
    jumpOnClick = !jumpOnClick;
    document.getElementById('click_to_jump').className = (jumpOnClick ? "util sel" : "util nosel");
    document.querySelector(':root').style.setProperty('--word-pointer', jumpOnClick ? 'pointer' : 'auto');
}

function setSpeed(val, target) {
    player.playbackRate = val;
    let other = ['0_5', '1_0', '1_25', '1_5', '1_75', '2_0', '2_5', '3_0'];
    for (let i = 0; i < other.length; i++) {
        document.getElementById('speed_' + other[i]).className = (other[i] == target ? "util sel" : "util nosel");
    }
}

function setSize(val, target) {
    let perc = document.documentElement.scrollTop / document.documentElement.scrollHeight;
    document.documentElement.style.setProperty("--content-size", val + "%");
    document.documentElement.scrollTop = document.documentElement.scrollHeight * perc;
    let other = ['100', '125', '150', '200'];
    for (let i = 0; i < other.length; i++) {
        document.getElementById('size_' + other[i]).className = (other[i] == target ? "util sel" : "util nosel");
    }
}

function setupMediaHandlers() {
    const ms = navigator.mediaSession;
    if (ms) {
        ms.setActionHandler("play", () => {
            play();
        });
        ms.setActionHandler("pause", () => {
            document.getElementById('player').pause();
        });
        ms.setActionHandler("seekbackward", (seekOffset) => {
            movePara(true);
        });
        ms.setActionHandler("seekforward", (seekOffset) => {
            movePara(false);
        });
    }
}

function playerLoaded() {
    if (playerLeftToLoad > 0) {
        playerLeftToLoad--;
    }

    if (playerLeftToLoad == 0) {
        playerLeftToLoad = -1;

        if ('audioSession' in navigator) {
            const as = navigator.audioSession;
            if (as) {
                as.type = 'playback';
                as.addEventListener("onstatechange", () => {
                    if (as.state === 'interrupted') {
                        isInterrupted = true;
                        if (!player.paused) {
                            player.pause();
                        }
                    }
                    if (as.state === 'inactive') {
                        if (isInterrupted) {
                            isInterrupted = false;
                            if (player.paused) {
                                play();
                            }
                        }
                    }
                });
            }
        }

        if ('mediaSession' in navigator) {
            const ms = navigator.mediaSession;
            if (ms) {
                let title = "Podcast", album = "Scott's Podcasts";
                if (typeof meta['title'] !== 'undefined' && meta['title'] !== null && meta['title'].length > 0) {
                    let temp = JSON.parse(atob(meta['title']));
                    if (temp['link_title'].length > 0) {
                        title = temp['link_title'];
                    }
                    if (temp['feed_title'].length > 0) {
                        album = temp['feed_title'];
                    }
                }
                ms.metadata = new MediaMetadata({
                    title: title,
                    album: album,
                    artist: album,
                    artwork: [
                        { src: "https://scotts-podcasts.s3.amazonaws.com/artwork_512.png", sizes: '512x512', type: 'image/png' },
                    ],
                });
                setupMediaHandlers();
            }
        }

        let dur = meta['dur'] !== null ? meta['dur'] : player.duration;
        document.getElementById("pos").max = dur * 10;

        paras.forEach(e => {
            e.start = e.at / dur;
            e.end = e.atEnd / dur;
        });

        parasReady = true;
        posChanging();

        if (player.newTarget !== null) {
            let temp = player.newTarget;
            player.newTarget = null;
            move(temp);
        }
    }
}

function turnOnWakeLock() {
    if ('wakeLock' in navigator) {
        if (requestWakeLock !== null && wakeLock === null && document.visibilityState === 'visible') {
            requestWakeLock();
        }
    }
}

function turnOffWakeLock() {
    if ('wakeLock' in navigator) {
        if (wakeLock !== null) {
            wakeLock.release().then(() => {
                wakeLock = null;
            });
        }
    }
}

function setupWakeLock() {
    if ('wakeLock' in navigator) {
        requestWakeLock = async () => {
            try {
                wakeLock = await navigator.wakeLock.request('screen');
            } catch (err) { }
        };
    }
}

function windowBlur() {
    if (document.getElementById("dropdown").className == "dropdown showDrop") {
        hideDrop();
    }
}

function loadTick() {
    if (tickURL != null && selfID != null) {
        fetch(tickURL)
            .then(r => r.json())
            .then(d => {
                tickStatus = d;
                let now = new Date().valueOf();
                if (tickStatus["rate_sec"] < 1) {
                    tickStatus["rate_sec"] = 1;
                }
                tickStatus["reload"] = now + tickStatus["expires_sec"] * 1000;
                tickStatus["update"] = now + tickStatus["rate_sec"] * 1000;
                tickStatus["last"] = 0;
            })
            .catch(e => {
                tickURL = null;
                selfID = null;
            });
    }
}

function publishTick(val, duration, finalCall=false) {
    if (tickStatus != null) {
        let now = new Date().valueOf();
        if (now >= tickStatus["reload"]) {
            tickStatus = null;
            loadTick();
        } else if (finalCall || (now >= tickStatus["update"] && Math.abs(val - tickStatus["last"]) >= (tickStatus["rate_sec"] / 2))) {
            tickStatus["last"] = val;
            tickStatus["update"] = now + tickStatus["rate_sec"] * 1000;
            fetch(tickStatus["url"], {
                keepalive: finalCall,
                method: 'PUT',
                headers: {
                    'Content-type': ''
                },
                body: JSON.stringify({
                    'id': selfID, 
                    at: parseFloat(val.toFixed(2)), 
                    dur: parseFloat(duration.toFixed(2)),
                    update: new Date(now).toISOString(),
                }),
            }).catch(e => { });
        }
    }
}

window.addEventListener("beforeunload", function(e){
    publishTick(player.currentTime, player.duration, true);
});

async function decodeData(value) {
    const b64toBlob = (base64, type = 'application/octet-stream') => 
        fetch(`data:${type};base64,${base64}`).then(res => res.blob());
    const blob = await b64toBlob(value);
    const ds = new DecompressionStream("gzip");
    const decomp = blob.stream().pipeThrough(ds);
    const decoded = await new Response(decomp).blob();
    const text = await decoded.text();
    const parsed = JSON.parse(text);
    parsed['word'] = parsed['word'].split("|");
    return parsed;
}

document.addEventListener("DOMContentLoaded", function(event) {
    window.history.replaceState({}, null, window.location.href.split("?")[0].split("#")[0]);

    if (meta['dur'] !== null) {
        document.getElementById("pos").max = meta['dur'] * 10;
        posChanging(false);
    }

    player = document.getElementById('player');
    player.newTarget = null;

    loadTick();

    let targetPos = null;
    
    if (targetPos === null) {
        try {
            let temp = getParam("start");
            if (temp !== null && temp.length > 0) {
                targetPos = parseFloat(temp) / 10;
            }
        } catch (e) { }
    }
    if (targetPos === null) {
        try {
            let temp = urlHash;
            if (temp.length > 1) {
                targetPos = parseFloat(temp.substr(1)) / 10;
            }
        } catch (e) { }
    }
    if (targetPos === null) {
        try {
            let tempID = window.localStorage.getItem(meta['id']), 
                tempPos = window.localStorage.getItem('pos');
            if (tempID == meta['id']) {
                tempPos = parseFloat(tempPos);
                tempPos -= 5;
                if (tempPos > 0) {
                    targetPos = tempPos;
                }
            }
        } catch (e) { }
    }

    player.addEventListener("loadedmetadata", function() {
        playerLoaded();
        if (targetPos !== null) {
            player.currentTime = targetPos;
        }
    });
    player.addEventListener("loadeddata", function() {
        playerLoaded();
    });
    player.addEventListener("timeupdate", function () {
        let at = player.currentTime;
        publishTick(at, player.duration);
        if (player.paused == playerIsPlaying) {
            player.dispatchEvent(new CustomEvent(player.paused ? 'pause' : 'play'));
        }
        if (!isUserMoving) {
            document.getElementById("pos").value = at * 10;
            posChanging();
        }
        let lastElem = null, 
            highlightTime = 1.0 * player.playbackRate;

        if (lastHighlighted !== null) {
            if (at >= lastHighlighted[0].at && at < lastHighlighted[lastHighlighted.length-1].atEnd) {
                lastElem = lastHighlighted[0];
            } else if (lastHighlighted[lastHighlighted.length-1].hasOwnProperty("next")) {
                let started = lastHighlighted[lastHighlighted.length-1].next, ended = started;

                while (true) {
                    if (at >= started.at && at < ended.atEnd) {
                        lastElem = started;
                        break;
                    }
                    if (ended.atEnd - started.at > highlightTime) {
                        break;
                    }
                    if (ended.hasOwnProperty("next")) {
                        ended = ended.next;
                    } else {
                        break;
                    }
                }
            }
        }
        if (lastElem === null) {
            lastElem = bisect(byTime, e => e.at <= at, false);
        }

        let isIn = false;
        if (lastElem !== null && lastHighlighted !== null) {
            lastHighlighted.forEach((e) => {
                if (e === lastElem) {
                    isIn = true;
                }
            });
        }
        if (lastElem !== null && (lastHighlighted === null || (lastHighlighted !== null && !isIn))) {
            if (at >= 60) {
                window.localStorage.setItem('wordID', meta['id']);
                window.localStorage.setItem('pos', at);
            }
            let stack = [lastElem];
            lastElem.className = 'current';
            while ((stack[stack.length-1].atEnd - stack[0].at) <= highlightTime && stack[stack.length-1].hasOwnProperty("next")) {
                stack[stack.length-1].next.className = 'current';
                stack.push(stack[stack.length-1].next);
            }
            if (stack.length == 1) {
                stack[0].className = 'current left right';
            } else {
                stack[0].className = 'current left';
                stack[stack.length - 1].className = 'current right';
            }
            stack.forEach((e) => {
                e.className += e.isDiff ? ' diff': '';
            });
            if (autoScroll) {
                stack[stack.length-1].scrollIntoView({
                    "block": "nearest",
                    "behavior": "smooth",
                });
            }
            if (lastHighlighted !== null) {
                lastHighlighted.forEach((e) => {
                    e.className = 'word' + (e.isDiff ? ' diff' : '');
                    e.para.className = '';
                });
            }
            stack.forEach((e) => {
                e.para.className = 'current';
            });
            lastHighlighted = stack;
        }
    }, false);

    player.addEventListener('play', function () {
        if (!playerIsPlaying) {
            document.getElementById("playButton").className.baseVal = "playPause pause";
            playerIsPlaying = true;
            turnOnWakeLock();
            if ('audioSession' in navigator) {
                const as = navigator.audioSession;
                if (as) {
                    as.type = 'playback';
                }
            }
        }
    });

    player.addEventListener('pause', function () {
        if (playerIsPlaying) {
            document.getElementById("playButton").className.baseVal = "playPause play";
            playerIsPlaying = false;
            turnOffWakeLock();
        }
    });

    decodeData(meta['words']).then((words) => {
        let children = [], lastPara = null, lastAt = 0, lastHeader = 0, lastSpeakerID=' ';
        for (let i = 0; i < words['word'].length; i++) {
            let at = words['off'][i], word = words['word'][i], para = words['para'].charAt(i), speakerID = words['speaker'].charAt(i);
            at += lastAt;
            lastAt = at;
            at /= 100;
            if (para == '.') {
                lastPara = document.createElement("p");
                lastPara.at = at;
                lastPara.atEnd = at;
                let temp = document.createElement("span");
                temp.className = "timecode";
                temp.appendChild(document.createTextNode(getTick(at) + ":"));
                lastPara.appendChild(temp);
                children.push(lastPara);
                paras.push(lastPara);
            }
            lastPara.children[lastPara.children.length-1].textContent += ' ';
            lastPara.atEnd = at;

            let temp = document.createElement("span");
            if (byTime.length > 0) {
                byTime[byTime.length - 1].atEnd = at;
                byTime[byTime.length - 1].next = temp;
            }
            temp.at = at;
            temp.onclick = move;
            temp.className = "word";
            if (para == '.' && speakerID != lastSpeakerID) {
                if (speakerID != ' ') {
                    let speaker = document.createElement("span");
                    speaker.textContent = speakerID + ": ";
                    speaker.className = "speaker";
                    lastPara.appendChild(speaker);
                }
                lastSpeakerID = speakerID;
            }
            if (speakerID != lastSpeakerID) {
                temp.className += " diff";
                temp.isDiff = true;
            } else {
                temp.isDiff = false;
            }
            temp.appendChild(document.createTextNode(word));
            temp.para = lastPara;
            lastPara.appendChild(temp);
            byTime.push(temp);
        };
        if (byTime.length > 0) {
            byTime[byTime.length - 1].atEnd = (lastAt/100) + 3600;
        }
        document.getElementById("pos").max = (lastAt/100) * 10;
        document.getElementById("transcript").append(...children);

        let hidden, visibilityChange;
        if (typeof document.hidden !== "undefined") {
            hidden = "hidden";
            visibilityChange = "visibilitychange";
        } else if (typeof document.msHidden !== "undefined") {
            hidden = "msHidden";
            visibilityChange = "msvisibilitychange";
        } else if (typeof document.webkitHidden !== "undefined") {
            hidden = "webkitHidden";
            visibilityChange = "webkitvisibilitychange";
        }

        function pageAwake() {
            if (wakeLock !== null) {
                wakeLock = null;
                turnOnWakeLock();
            }
            if (lastHighlighted !== null && autoScroll && lastHighlighted.length > 0) {
                lastHighlighted[lastHighlighted.length-1].scrollIntoView({
                    "block": "nearest",
                    "behavior": "smooth",
                });
            }
        }
        document.addEventListener(visibilityChange, () => { 
            if (!document[hidden]) {
                pageAwake();
            }
        });
        document.addEventListener('pageshow', pageAwake);
        document.addEventListener('focus', pageAwake);
        document.addEventListener('scroll', updateScrolls);
        window.addEventListener('blur', windowBlur);
        setupWakeLock();
        playerLoaded();
        extraSetup();
    });
});
extraScript();
/* --- Minify End --- */
</script>
</head>
<body>

<div class="rows header">
    <svg id="playButton" class="playPause play" width="50" height="50" id="btnPlay" viewBox="-2 -2 108 108" onclick="play()">
        <circle class="forPlay" cx="51" cy="51" r="50" style="stroke-width:1px;stroke:#000;" />
        <line class="forPlay" x1="38" y1="30" x2="38" y2="70" style="stroke-width:8px;stroke:#bbf;stroke-linecap:round;" />
        <path class="forPlay" d="M 38 30 L 70 50 L 38 70" rx="10" ry="10" style="stroke-width:8px;stroke:#bbf;fill:#bbf;stroke-linejoin:round;stroke-linecap:round;" />
        <circle class="forPause" cx="51" cy="51" r="50" style="stroke-width:5px;stroke:#bbf;" />
        <line class="forPause" x1="38" y1="30" x2="38" y2="70" style="stroke-width:8px;stroke:#bbf;stroke-linecap:round;" />
        <path class="forPause" d="M 66 30 L 66 50 L 66 70" rx="10" ry="10" style="stroke-width:8px;stroke:#bbf;fill:#bbf;stroke-linejoin:round;stroke-linecap:round;" />
    </svg>
    <input class="slider fill" type="range" min="0" max="1000" value="0" id="pos" onchange="posChange()" oninput="posChanging()" onmousedown="posMoving()" onmouseup="posMoved()">
    <span id="posText">0:00:00<br><font size="-1">-0:00:00</font></span>
    <span class="link">
        <svg fill="#bbf" stle="width:50px" viewBox="-5 -5 70 70" width="24" height="24" onclick="showLinks()" xmlns="http://www.w3.org/2000/svg" fill-rule="evenodd" clip-rule="evenodd">
            <g transform="matrix(1,0,0,1,-1088,-192)">
                <g>
                    <g transform="matrix(1.50868,0,0,1.01217,70.647,191.772)">
                        <g transform="matrix(0.149202,0,0,0.173437,664.206,42.142)">
                            <rect x="103.288" y="8.535" width="71.218" height="34.133" style="fill-rule:nonzero;"/>
                        </g>
                        <g transform="matrix(0.149202,0,0,0.173437,664.345,27.4)">
                            <rect x="103.288" y="8.535" width="141.366" height="34.133" style="fill-rule:nonzero;"/>
                        </g>
                        <g transform="matrix(0.149202,0,0,0.173437,664.345,12.658)">
                            <rect x="103.288" y="8.535" width="212.447" height="34.133" style="fill-rule:nonzero;"/>
                        </g>
                    </g>
                </g>
            </g>
        </svg>
    </span>
    <!-- EXTRA_WIDGETS -->
</div>

<div class="content" id="transcript"></div>
<div class="overlay hidden" id="overlay" onclick="hideDrop()"></div>
<div class="dropdown hidden" id="setpos">
    Set position:
    <form action="" onsubmit="return posSelected(event);">
        <input type="text" size="8" autocomplete="off" autocorrect="off" id="enteredPos" inputmode="decimal" value="0:00:00">
        <input type="submit" value="Jump">
    </form>
</div>
<div class="dropdown hidden" id="dropdown">
    <span class="util" onclick="getLink();">Copy link...</span>
    <span class="util" onclick="showPos()" title="Ctrl-S">Set position...</span>
    Options:<br>
    <div style="padding-left: 1em;">
        <span class="util sel" id="click_to_jump" onclick="onClickToJump()">Jump on click</span>
        <span class="util sel" id="auto_scroll" onclick="onAutoScroll()">Auto scroll</span>
    </div>
    Playback speed:<br>
    <div style="padding-left: 1em;">
        <span class="util nosel" id="speed_0_5" onclick="setSpeed(0.5, '0_5')">0.50x</span>
        <span class="util sel" id="speed_1_0" onclick="setSpeed(1, '1_0')">1.00x</span>
        <span class="util nosel" id="speed_1_25" onclick="setSpeed(1.25, '1_25')">1.25x</span>
        <span class="util nosel" id="speed_1_5" onclick="setSpeed(1.5, '1_5')">1.50x</span>
        <span class="util nosel" id="speed_1_75" onclick="setSpeed(1.75, '1_75')">1.75x</span>
        <span class="util nosel" id="speed_2_0" onclick="setSpeed(2, '2_0')">2.00x</span>
        <span class="util nosel" id="speed_2_5" onclick="setSpeed(2.5, '2_5')">2.50x</span>
        <span class="util nosel" id="speed_3_0" onclick="setSpeed(3, '3_0')">3.00x</span>
    </div>
    Font size:<br>
    <div style="padding-left: 1em;">
        <span class="util sel" id="size_100" onclick="setSize(100, '100')">100%</span>
        <span class="util nosel" id="size_125" onclick="setSize(125, '125')">125%</span>
        <span class="util nosel" id="size_150" onclick="setSize(150, '150')">150%</span>
        <span class="util nosel" id="size_200" onclick="setSize(200, '200')">200%</span>
    </div>
</div>

<audio id="player" preload="metadata"><source src="[[MP3_NAME]]"></audio>

</body>
</html>
