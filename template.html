<!DOCTYPE html>
<html><head>
<meta charset="utf-8"/>
<link rel="apple-touch-icon" href="favicon.png"/>
<link rel="shortcut icon" href="favicon.png"/>
<link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto" />
<meta name="viewport" content="width=device-width"/>
<meta name="viewport" content="initial-scale=1.0"/>
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="ligth-dark(#ddd,#222)">
<title>[[TITLE]]</title>
<style>
:root{
    --content-size:100%;
    --word-pointer:pointer;
    --widget-height:62px;
    --extra_height:1.0;
    color-scheme:light dark;
}

html,
body{
    height:100%;
    margin:0;
    padding:0;
    border:0;
    background-color:light-dark(#ccc,#333);
    color:light-dark(#333,#ccc);
    font-family:"Roboto",sans-serif;
    font-size:12pt;
    box-sizing:border-box;
}

::selection {
    background-color:#44c;
    color:#fff;
}

.picker {
    position:fixed;
    display:none;
    background-color:#55f;
    border-color:#55f;
    color:#eee;
    border-width:4px;
    border-style:solid;
    padding:2px;
    filter:drop-shadow(5px 5px 10px light-dark(#fff,#000));
    z-index:15000;
}

.picker span {
    cursor:pointer;
    color:#fff;
}

.picker:after {
    position:absolute;
    content:"";
    border-top:15px solid light-dark(#00a,#55f);
    border-left:15px solid transparent;
    border-bottom:15px solid transparent;
    border-right:15px solid transparent;
    top:100%;
    left:50%;
    transform:translate(-50%, 0);
    display:block;
}

.overlay{
    position:fixed;
    background-color:rgba(0,0,0,.25);
    top:0;
    left:0;
    width:100%;
    height:100%;
}

.content{
    font-size:var(--content-size);
    padding:10px;
    padding-top:calc(var(--widget-height) * var(--extra_height));
    padding-bottom:30px;
}

.cols{
    display:flex;
    flex-flow:column;
}

.rows{
    display:flex;
    flex-flow:row;
}

@keyframes fade{
    0%{opacity:0;transform:translateX(4em);}
    100%{opacity:1;transform:translateX(0em);}
}

@-webkit-keyframes fade{
    0%{opacity:0;transform:translateX(4em);}
    100%{opacity:1;transform:translateX(0em);}
}

@keyframes unfade{
    0%{opacity:1;transform:translateX(0em);}
    100%{opacity:0;transform:translateX(4em);}
}

@-webkit-keyframes unfade{
    0%{opacity:1;transform:translateX(0em);}
    100%{opacity:0;transform:translateX(4em);}
}

.hideDrop{
    -webkit-animation:unfade 0.25s;
    animation:unfade 0.25s;
}

.showDrop{
    -webkit-animation:fade 0.25s;
    animation:fade 0.25s;
}

.dropdown{
    z-index: 14000;
    position:fixed;
    top:calc((var(--widget-height) * var(--extra_height)) - 10px);
    width:10em;
    left:calc(100% - 10em);
    align-items:center;
    padding:10px;
    line-height:150%;
    background-color:light-dark(#ddd,#222);
    box-shadow:0 1px 2px hsla(0,0%,0%,0.1),0 1px 4px hsla(0,0%,0%,0.1),0 2px 8px hsla(0,0%,0%,0.1);
}

#dropdown_segs {
    width: 30em;
    left:calc(100% - 30em);
    z-index: 14500;
    font-size: 80%;
}

.util{
    cursor:pointer;
    color:light-dark(#004,#bbf);
    overflow:hidden;
    width:100%;
    display:block;
}

.util:hover{
    background-color:light-dark(#66a,#559);
}

.header{
    align-items:center;
    background-color:light-dark(#ddd,#222);
    position:fixed;
    box-sizing:border-box;
    top:-10px;
    padding-top:10px;
    left:0;
    width:100%;
    height:calc(var(--widget-height) * var(--extra_height));
    box-shadow:0 1px 2px hsla(0,0%,0%,0.1),0 1px 4px hsla(0,0%,0%,0.1),0 2px 8px hsla(0,0%,0%,0.1);
    z-index:100000;
}

.sel::before{
    content:"\2022\00a0";
}

.nosel::before{
    content:"\00a0\00a0";
}

.fill{
    flex:100%;
}

.fillToEdge{
    height:100%;
    width:100%;
}

span.current{
    color:light-dark(#000,#fff);
    background:light-dark(#c77,#833);
    cursor:var(--word-pointer);
    scroll-margin:calc(1.5em + var(--widget-height)) 0 2.5em 0;
}

span.left{
    margin-left:-5px;
    padding-left:5px;
    border-radius:3px 0 0 3px;
}

span.right{
    border-radius:0 3px 3px 0;
}

span.word{
    cursor:var(--word-pointer);
    scroll-margin:2.5em 0;
}

p{
    padding:4px 0;
    margin-left:2ch;
    text-indent:-2ch;
    margin-top:.1em;
    margin-bottom:.1em;
    line-height:1.3;
}

div.segment p.segment{
    position:-webkit-sticky;
    position:sticky;
    margin:0;
    padding:0;
    top:calc(var(--widget-height) * var(--extra_height) - 10px);
 
    margin:0px;
    padding:3px 3ch;
    margin-left:-4ch;
    margin-right:0ch;
    
    font-size:80%;
    background-color:light-dark(#a2b2c5,#3a4a5d);
    color:light-dark(#222,#ddd);
    
    box-shadow:0 2px 4px rgba(0, 0, 0, 0.2);
    
    width:100%;
}

@media only screen and (max-width:600px) {
    p.segment {
        margin-left:-2ch;
        margin-right:0;
        padding:3px 1ch;
        width:calc(100% + 2ch);
    }
}

p.current{
    background-color:light-dark(#bbb,#444);
    box-shadow:4px 0 0 light-dark(#bbb,#444),-2ch 0 0 light-dark(#bbb,#444);
    border-radius:5px;
    scroll-margin:2.5em 0;
}

@media only screen and (max-width:600px){
    :root{
        --extra_height:1.3;
    }
    body{
        touch-action:pan-y;
    }
    span.current{
        scroll-margin:calc(1.5em + (var(--widget-height) * var(--extra_height))) 0 2.5em 0;
    }
    .playPause{
        transform:scale(1.9);
    }
    p{
        margin-left:0;
        text-indent:0;
    }
    p.current{
        box-shadow:4px 0 0 light-dark(#bbb,#444),-4px 0 0 light-dark(#bbb,#444);
    }
    p.segment{
        margin-left:-2ch;
        margin-right:0;
    }

}

@media only screen and (min-width:700px){
    .content{
        width:600px;
        margin-left:calc((100% - 600px) / 2);
    }
    p{
        margin-left:0;
    }
}

.timecode{
    color:light-dark(#555,#aaa);
}

.speaker{
    color:light-dark(#777,#888);
}

.diff{
    font-style:italic;
}

.hidden{
    display:none;
}

.playPause{
    margin-left:1em;
    margin-right:1em;
    margin-bottom:5px;
    margin-top:5px;
    cursor:pointer;
}

.play .forPause{
    display:none;
}

.slider{
    appearance:none;
    height:15px;
    margin:10px;
    border-radius:5px; 
    outline:none;
    background:light-dark(#bbb,#444);
}

.slider::-webkit-slider-thumb{
    appearance:none;
    width:26px;
    height:26px;
    border-radius:50%;
    background:light-dark(#77b,#bbf);
    cursor:pointer;
}

.slider::-moz-range-thumb{
    width:26px;
    height:26px;
    border-radius:50%;
    background:light-dark(#77b,#bbf);
    cursor:pointer;
}

.link{
    cursor:pointer;
    margin:10px;
}

.leftpad{
    margin:10px;
}

input[type=button],input[type=submit],input[type=reset]{
    background-color:light-dark(#bbb,#444);
    border:none;
    color:light-dark(#0d0d07, #f8f8f2);
    padding:2pt 20pt;
    text-decoration:none;
    cursor:pointer;
    font-family:Menlo,Monaco,Consolas,monospace;
    font-size:12pt;
}

input[type="text"],input[type="number"],textarea{
    background-color:light-dark(#fff,#000);
    color:light-dark(#131,#cec);
    font-family:Menlo,Monaco,Consolas,monospace;
    font-size:12pt;
    margin:3px;
    border-top-style:hidden;
    border-right-style:hidden;
    border-left-style:hidden;
    border-bottom-style:solid;
    border-bottom-width:1px;
    border-bottom-color:light-dark(#0d0d57,#a8a8f2);
    padding:2px;
}
</style>
<script>
const extraMove=()=>{};
const extraScript=()=>{};
const extraSetup=()=>{};
const meta={
    words:"[[WORDS_VAR]]",
    title:"[[TITLE_META]]",
    id:"[[WORD_ID]]",
    dur:"[[EXPECTED_DUR]]",
    src:"[[META_MP3_NAME]]",
    segs:"[[SEGMENTS_DATA]]"
};
/* --- Minify Start --- */
function getParam(name, decode) {
    let ret = urlQuery.get(name);
    if (ret !== null && decode) { ret = atob(ret); }
    return ret
}

let timing = null;
let byTime = [];
let paras = [];
let parasReady = false;
let lastHighlighted = null;
let isUserMoving = false;
let scrollState = [-1, -1, -1];
let playerLeftToLoad = 3;
let playerIsPlaying = false;
let jumpOnClick = true;
let autoScroll = true;
let wakeLock = null;
let isInterrupted = false;
let player = null;
let requestWakeLock = null;
let urlQuery = new URLSearchParams(window.location.search);
let urlHash = window.location.hash;
let tickURL = getParam("tick_url", true);
let selfID = getParam("id");
let tickStatus = null;
let ignoreSelChange = false;
let lastPublishTick = 0;
let firstClick = true;
let pauseScroll = 0;

function move(secs) {
    if (!jumpOnClick) {
        return;
    }
    extraMove();
    if (secs.srcElement !== undefined) {
        secs = secs.srcElement.at;
    }
    if (playerLeftToLoad == -1) {
        let paused = player.paused;
        if (!paused) {
            play();
        }
        player.currentTime = secs;
        if (!paused || firstClick) {
            if (!paused || secs < 300) {
                play();
            }
            firstClick = false;
        }
        updateScrolls();
    } else {
        firstClick = false;
        player.newTarget = secs;
        if (player.paused) {
            play();
        }
    }
    firstClick = false;
};

function toPrevPara(elem, nextSegment) {
    while (true) {
        if (elem.i > 0) {
            elem = paras[elem.i - 1];
            if ((nextSegment && elem.segment) || !nextSegment) {
                return elem;
            }
        } else {
            return null;
        }
    }
}

function toNextPara(elem, nextSegment) {
    while (true) {
        if (elem.i < paras.length - 1) {
            elem = paras[elem.i + 1];
            if ((nextSegment && elem.segment) || !nextSegment) {
                return elem;
            }
        } else {
            return null;
        }
    }
}

function movePara(prevPara, nextSegment=false) {
    let temp = null;
    if (temp === null && lastHighlighted !== null) {
        temp = prevPara ? toPrevPara(lastHighlighted[0].para, nextSegment) : toNextPara(lastHighlighted[lastHighlighted.length-1].para, nextSegment);
    }
    if (temp === null && parasReady) {
        temp = paras[0];
    }
    if (temp !== null) {
        temp = temp.childNodes;
        for (let i = 0; i < temp.length; i++) {
            if (temp[i].hasOwnProperty('at')) {
                player.currentTime = (temp[i].at + temp[i].at) / 2;
                return true;
            }
        }
    }
}

function moveWord(prevWord) {
    if (lastHighlighted === null) {
        let line = paras[0], temp = line.childNodes;
        for (let i = 0; i < temp.length; i++) {
            if (temp[i].hasOwnProperty('at')) {
                let word = temp[i];
                player.currentTime = (word.at + word.atEnd) / 2;
                break
            }
        }
    } else {
        player.currentTime = prevWord ? lastHighlighted[0].at - (1.0 * player.playbackRate) : lastHighlighted[lastHighlighted.length-1].atEnd + 0.1;
    }
}

function downloadURL(data, fileName) {
    const a = document.createElement('a');
    a.href = data;
    a.download = fileName;
    document.body.appendChild(a);
    a.style.display = 'none';
    a.click();
    a.remove();
}

function downloadBlob(data, fileName, mimeType) {
    const blob = new Blob([data], {
        type: mimeType
    });
    const url = window.URL.createObjectURL(blob);
    downloadURL(url, fileName);
    setTimeout(() => window.URL.revokeObjectURL(url), 1000);
}

async function getData(uri, start, len) {
    const resp = await fetch(
        uri, 
        {
            'headers': {
                'Range': 'bytes=' + start + "-" + (start + len - 1),
            },
        },
    );
    const asBlob = await resp.blob();
    return asBlob;
}

function nearestNode(val, x, pass) {
    if (val === null) {
        return null;
    }

    if (val.hasOwnProperty(x)) {
        return val;
    } else if (val.parentNode.hasOwnProperty(x)) {
        return val.parentNode;
    }

    if (pass == "prev") {
        return nearestNode(val.previousElementSibling, x, "--");
    } else if (pass == "next") {
        return nearestNode(val.nextElementSibling, x, "--");
    }

    return null;
}

let lastSelFrom = null, lastSelTo = null;
function closeSel() {
    window.getSelection().removeAllRanges();
    ignoreSelChange = false;
    picker.style.display = 'none';
}
function copySel() {
    if (lastSelFrom != null && lastSelTo != null) {
        let nodeFrom = nearestNode(lastSelFrom, 'wordID', "next");
        let nodeTo = nearestNode(lastSelTo, 'wordID', "prev");
        if (nodeFrom !== null && nodeTo !== null) {
            if (nodeFrom.at > nodeTo.at) {
                let temp = nodeFrom;
                nodeFrom = nodeTo;
                nodeTo = temp;
            }
            let vals = [];
            byTime.forEach(e => {
                if (e.at >= nodeFrom.at && e.at <= nodeTo.at) {
                    if (vals.length == 0) {
                        vals.push(getTick(e.at) + ':');
                    }
                    vals.push(e.innerText.trim());
                }
            });
            navigator.clipboard.writeText(vals.join(' '));
            closeSel();
        }
    }
}
function downloadSel(preview, e) {
    e.preventDefault();
    if (document.getElementById("preview").source != null) {
        document.getElementById("preview").source.stop();
        return;
    }
    if (lastSelFrom != null && lastSelTo != null) {
        let nodeFrom = nearestNode(lastSelFrom, 'wordID', "next");
        let nodeTo = nearestNode(lastSelTo, 'wordID', "prev");
        if (nodeFrom !== null && nodeTo !== null) {
            if (nodeFrom.at > nodeTo.at) {
                let temp = nodeFrom;
                nodeFrom = nodeTo;
                nodeTo = temp;
            }
            let posStart = timing[(nodeFrom.wordID - parseInt(document.getElementById("padBefore").value)) * 2];
            let posEnd = timing[(nodeTo.wordID + parseInt(document.getElementById("padAfter").value)) * 2 + 1];
            if (posStart > 0 && posEnd > 0) {
                let url = document.getElementById('player').childNodes[0].src;
                let fn = url.replace(/^.*\//, "");
                fn = fn.replace(/\.[^/.]+$/, "");
                fn = decodeURI(fn.replaceAll("+", " "));
                fn += "_" + getTick(nodeFrom.at).replaceAll(":", "-") + "_" + getTick(nodeTo.at).replaceAll(":", "-") + ".mp3";
                getData(url, posStart, posEnd - posStart).then(data => {
                    if (preview) {
                        data.arrayBuffer().then(arrayBuffer => {
                            let context = new AudioContext();
                            context.decodeAudioData(arrayBuffer, (buffer) => {
                                var source = context.createBufferSource();
                                document.getElementById("preview").source = source;
                                source.onended = () => {
                                    document.getElementById("preview").innerText = "Preview";
                                    document.getElementById("preview").source = null;
                                };
                                document.getElementById("preview").innerText = "Stop";
                                source.buffer = buffer;
                                source.connect(context.destination);
                                source.start(0);
                            });
                        });
                    } else {
                        downloadBlob(data, fn, "audio/mp3");
                        closeSel();
                    }
                });
            }
        }
    }
}

document.addEventListener('keydown', e => {
    if (!e.altKey && !e.ctrlKey && !e.metaKey && !e.shiftKey) {
        if (document.getElementById("overlay").className === "overlay hidden") {
            if (e.code === 'Space') {
                e.preventDefault();
                play();
                return true;
            }

            if (new Set(['ArrowUp', 'ArrowDown']).has(e.code)) {
                e.preventDefault();
                movePara(e.code === 'ArrowUp');
                return true;
            }
            else if (new Set(['ArrowLeft', 'ArrowRight']).has(e.code)) {
                e.preventDefault();
                moveWord(e.code === 'ArrowLeft');
                return true;
            }
        } else {
            if (e.code === 'Escape') {
                hideDrop();
                return true;
            }
        }
    }
    if (!e.altKey && e.ctrlKey && !e.metaKey && !e.shiftKey) {
        if (meta['segs'].length > 1) {
            if (new Set(['ArrowUp', 'ArrowDown']).has(e.code)) {
                e.preventDefault();
                movePara(e.code === 'ArrowUp', true);
                return true;
            }
        }
    }
    if (e.key === 's' && !e.altKey && e.ctrlKey && !e.metaKey && !e.shiftKey) {
        e.preventDefault();
        showPos();
        return true;
    }
});

function pad(value, width=1, padChar='0') {
    value = Math.floor(value) + '';
    return value.length >= width ? value : new Array(width - value.length + 1).join(padChar) + value;
};

function getTick(at) {
    return pad(at / 3600) + ":" + pad((at % 3600) / 60, 2) + ":" + pad(at % 60, 2);
}

function play() {
    if (playerLeftToLoad >= 0) {
        playerLeftToLoad = 0;
        playerLoaded();
    }

    if (player.paused) {
        player.play();
    } else {
        player.pause();
    }
}

function posChange() {
    move(document.getElementById("pos").value / 10);
}

function posMoving() {
    isUserMoving = true;
}

function posMoved() {
    isUserMoving = false;
}

function bisect(target, handler, invert) {
    let start = 0, end = target.length - 1;
    let valid = null;
    while (start != end) {
        let mid = Math.floor((start + end) / 2);
        if (handler(target[mid])) {
            if (invert) {
                end = mid;
            } else {
                start = mid + 1;
            }
            valid = target[mid];
        } else {
            if (invert) {
                start = mid + 1;
            } else {
                end = mid;
            }
        }
    }
    if (handler(target[start])) {
        return target[start];
    } else {
        return valid;
    }
}

function updateScrolls() {
    if (!parasReady) {
        return;
    }

    let pos = document.getElementById("pos"), loc = pos.value / pos.max, 
        temp = [window.innerHeight, paras[paras.length - 1].getBoundingClientRect().bottom, loc];
    if (temp[0] == scrollState[0] && temp[1] == scrollState[1] && temp[2] == scrollState[2]) {
        return;
    }
    scrollState = temp;

    let pageStart = bisect(paras, e => e.getBoundingClientRect().bottom >= 50, true), 
        pageEnd = bisect(paras, e => e.getBoundingClientRect().top <= window.innerHeight, false);

    if (pageStart !== null && pageEnd !== null) {
        function calcPerc(e, invert) {
            let rect = e.getBoundingClientRect(), 
                perc = (invert ? (window.innerHeight - rect.top) : (rect.bottom - 50)) / (rect.bottom - rect.top);
            perc = perc < 0 ? 0 : (perc > 1 ? 1 : perc);
            if (invert) {
                return ((e.end * perc) + (e.start * (1 - perc)));
            } else {
                return ((e.start * perc) + (e.end * (1 - perc)));
            }
        }
        
        pageStart = calcPerc(pageStart, false) ;
        pageEnd = calcPerc(pageEnd, true) ;

        let done = 'light-dark(#aaa,#555)', togo = 'light-dark(#ccc,#333)', page = 'light-dark(#559,#66a)', view = 3;
        if (pageEnd <= loc) {
            view = 1;
        } else if (pageStart >= loc) {
            view = 2;
        }

        loc = `calc((100% - 26px) * ${loc} + 13px)`;
        pageStart = `calc((100% - 26px) * ${pageStart} + 13px)`;
        pageEnd = `calc((100% - 26px) * ${pageEnd} + 13px)`;
        let temp = '';
        if (view == 1) {
            temp = `,${done} 0% ${pageStart},${page} ${pageStart} ${pageEnd},${done} ${pageStart} ${loc},${togo} ${loc} 100%`;
        } else if (view == 2) {
            temp = `,${done} 0% ${loc},${togo} ${loc} ${pageStart},${page} ${pageStart} ${pageEnd},${togo} ${pageEnd} 100%`;
        } else {
            temp = `,${done} 0% ${pageStart},${page} ${pageStart} ${pageEnd},${togo} ${pageEnd} 100%`;
        }
        pos.style.background = 'linear-gradient(to right' + temp + ')';
    }
}

function posChanging(includeScrolls=true) {
    document.getElementById("posCurrent").innerText = getTick(pos.value / 10);
    document.getElementById("posLeft").innerText = getTick((pos.max - pos.value) / 10);
}

function hideDrop() {
    let drop = document.getElementById("dropdown");
    if (drop.className == "dropdown showDrop") {
        drop.className = "dropdown hideDrop";
    }
    let dropSeg = document.getElementById("dropdown_segs");
    if (dropSeg.className == "dropdown showDrop") {
        dropSeg.className = "dropdown hideDrop";
    }
    let setpos = document.getElementById("setpos");
    if (setpos.className == "dropdown showDrop") {
        setpos.className = "dropdown hideDrop";
    }
    let overlay = document.getElementById("overlay");
    overlay.className = "overlay hidden";
}

function posSelected(e) {
    hideDrop();
    e.preventDefault = true;
    let newPos = document.getElementById('enteredPos').value;
    if (newPos.includes(":") || newPos.includes(".") || newPos.includes("-") || newPos.includes(",") || newPos.includes(" ")) {
        newPos = newPos.replace(/[,. -]/g, ":");
        newPos = newPos.split(":");
        if (newPos.length == 3 || newPos.length == 2) {
            let h = parseInt(newPos.length == 3 ? newPos[0] : '0'), 
                m = parseInt(newPos.length == 3 ? newPos[1] : newPos[0]), 
                s = parseInt(newPos.length == 3 ? newPos[2] : newPos[1]);
            if (h >= 0 && h <= 99 && m >= 0 && m <= 59 && s >= 0 && s <= 59) {
                let temp = h * 3600 + m * 60 + s;
                if (temp >= 0 && temp <= 43200) {
                    move(h * 3600 + m * 60 + s);
                }
            }
        }
    } else {
        let temp = parseFloat(newPos);
        if (temp >= 0 && temp <= 60) {
            move(temp * 60);
        } else if (temp > 60 && temp <= 43200) {
            move(temp);
        }
    }
    hideDrop();
    return false;
}

function showLinks() {
    let drop = document.getElementById("dropdown");
    if (!drop.hasOwnProperty('eventSetup')) {
        drop.eventSetup = true;
        drop.addEventListener('animationend', (e) => {
            if (drop.className == "dropdown hideDrop") {
                drop.className = "dropdown hideDrop hidden";
            }
        });
    }

    if (drop.className == "dropdown showDrop") {
        hideDrop();
    } else {
        drop.className = "dropdown showDrop";
        let overlay = document.getElementById("overlay");
        overlay.className = "overlay";
    }
}

function showSegs() {
    let dropSeg = document.getElementById("dropdown_segs");
    if (!dropSeg.hasOwnProperty('eventSetup')) {
        dropSeg.eventSetup = true;
        dropSeg.addEventListener('animationend', (e) => {
            if (dropSeg.className == "dropdown hideDrop") {
                dropSeg.className = "dropdown hideDrop hidden";
            }
        });
    }
    let drop = document.getElementById("dropdown");
    drop.className = "dropdown hideDrop hidden";

    dropSeg.className = "dropdown showDrop";
    let overlay = document.getElementById("overlay");
    overlay.className = "overlay";
}

function showPos() {
    let enteredPos = document.getElementById('enteredPos');
    enteredPos.value = getTick(player.currentTime);
    let setpos = document.getElementById("setpos");
    if (!setpos.hasOwnProperty('eventSetup')) {
        setpos.eventSetup = true;
        setpos.addEventListener('animationend', (e) => {
            if (setpos.className == "dropdown hideDrop") {
                setpos.className = "dropdown hideDrop hidden";
            }
        });
    }
    let drop = document.getElementById("dropdown");
    drop.className = "dropdown hideDrop hidden";

    setpos.className = "dropdown showDrop";
    let overlay = document.getElementById("overlay");
    overlay.className = "overlay";

    enteredPos.focus();
    enteredPos.select();
}

let clipboard = (function(window, document, navigator) {
    let textArea, copy;

    function isOS() {
        return navigator.userAgent.match(/ipad|iphone/i);
    }

    function createTextArea(text) {
        textArea = document.createElement('textArea');
        textArea.value = text;
        document.body.appendChild(textArea);
    }

    function selectText() {
        let range, selection;

        if (isOS()) {
            range = document.createRange();
            range.selectNodeContents(textArea);
            selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            textArea.setSelectionRange(0, 999999);
        } else {
            textArea.select();
        }
    }

    function copyToClipboard() {        
        document.execCommand('copy');
        document.body.removeChild(textArea);
    }

    copy = function(text) {
        createTextArea(text);
        selectText();
        copyToClipboard();
    };

    return {
        copy: copy
    };
})(window, document, navigator);

function getLink() {
    let uri = window.location.href.split("#")[0].split("?")[0] + "#" + Math.floor(player.currentTime * 10);
    clipboard.copy(uri);
    alert("Link copied to clipboard");
    hideDrop();
}

function onAutoScroll() {
    autoScroll = !autoScroll;
    document.getElementById('auto_scroll').className = (autoScroll ? "util sel" : "util nosel");
}

function onClickToJump() {
    jumpOnClick = !jumpOnClick;
    document.getElementById('click_to_jump').className = (jumpOnClick ? "util sel" : "util nosel");
    document.querySelector(':root').style.setProperty('--word-pointer', jumpOnClick ? 'pointer' : 'auto');
}

function setSpeed(val, target) {
    player.playbackRate = val;
    let other = ['0_5', '1_0', '1_25', '1_5', '1_75', '2_0', '2_5', '3_0'];
    for (let i = 0; i < other.length; i++) {
        document.getElementById('speed_' + other[i]).className = (other[i] == target ? "util sel" : "util nosel");
    }
}

function setSize(val, target) {
    let perc = document.documentElement.scrollTop / document.documentElement.scrollHeight;
    document.documentElement.style.setProperty("--content-size", val + "%");
    document.documentElement.scrollTop = document.documentElement.scrollHeight * perc;
    let other = ['100', '125', '150', '200'];
    for (let i = 0; i < other.length; i++) {
        document.getElementById('size_' + other[i]).className = (other[i] == target ? "util sel" : "util nosel");
    }
}

function setupMediaHandlers() {
    const ms = navigator.mediaSession;
    if (ms) {
        ms.setActionHandler("play", () => {
            play();
        });
        ms.setActionHandler("pause", () => {
            document.getElementById('player').pause();
        });
        ms.setActionHandler("seekbackward", (seekOffset) => {
            movePara(true);
        });
        ms.setActionHandler("seekforward", (seekOffset) => {
            movePara(false);
        });
    }
}

function playerLoaded() {
    if (playerLeftToLoad > 0) {
        playerLeftToLoad--;
    }

    if (playerLeftToLoad == 0) {
        playerLeftToLoad = -1;

        if ('audioSession' in navigator) {
            const as = navigator.audioSession;
            if (as) {
                as.type = 'playback';
                as.addEventListener("onstatechange", () => {
                    if (as.state === 'interrupted') {
                        isInterrupted = true;
                        if (!player.paused) {
                            player.pause();
                        }
                    }
                    if (as.state === 'inactive') {
                        if (isInterrupted) {
                            isInterrupted = false;
                            if (player.paused) {
                                play();
                            }
                        }
                    }
                });
            }
        }

        if ('mediaSession' in navigator) {
            const ms = navigator.mediaSession;
            if (ms) {
                let title = "Podcast", album = "Scott's Podcasts";
                if (typeof meta['title'] !== 'undefined' && meta['title'] !== null && meta['title'].length > 0) {
                    let temp = JSON.parse(atob(meta['title']));
                    if (temp['link_title'].length > 0) {
                        title = temp['link_title'];
                    }
                    if (temp['feed_title'].length > 0) {
                        album = temp['feed_title'];
                    }
                }
                ms.metadata = new MediaMetadata({
                    title: title,
                    album: album,
                    artist: album,
                    artwork: [
                        { src: "https://scotts-podcasts.s3.amazonaws.com/artwork_512.png", sizes: '512x512', type: 'image/png' },
                    ],
                });
                setupMediaHandlers();
            }
        }

        let dur = meta['dur'] !== null ? meta['dur'] : player.duration;
        document.getElementById("pos").max = dur * 10;

        paras.forEach(e => {
            e.start = e.at / dur;
            e.end = e.atEnd / dur;
        });

        parasReady = true;
        posChanging();
        updateScrolls();

        if (player.newTarget !== null) {
            let temp = player.newTarget;
            player.newTarget = null;
            move(temp);
        }
    }
}

function turnOnWakeLock() {
    if ('wakeLock' in navigator) {
        if (requestWakeLock !== null && wakeLock === null && document.visibilityState === 'visible') {
            requestWakeLock();
        }
    }
}

function turnOffWakeLock() {
    if ('wakeLock' in navigator) {
        if (wakeLock !== null) {
            wakeLock.release().then(() => {
                wakeLock = null;
            });
        }
    }
}

function setupWakeLock() {
    if ('wakeLock' in navigator) {
        requestWakeLock = async () => {
            try {
                wakeLock = await navigator.wakeLock.request('screen');
            } catch (err) { }
        };
    }
}

function windowBlur() {
    if (document.getElementById("dropdown").className == "dropdown showDrop") {
        hideDrop();
    }
}

function loadTick() {
    if (tickURL != null && selfID != null) {
        fetch(tickURL)
            .then(r => r.json())
            .then(d => {
                tickStatus = d;
                let now = new Date().valueOf();
                if (tickStatus["rate_sec"] < 1) {
                    tickStatus["rate_sec"] = 1;
                }
                tickStatus["reload"] = now + tickStatus["expires_sec"] * 1000;
                tickStatus["update"] = now + tickStatus["rate_sec"] * 1000;
                tickStatus["ignore"] = now + 300 * 1000;
                tickStatus["last"] = 0;
            })
            .catch(e => {
                tickURL = null;
                selfID = null;
            });
    }
}

function publishTick(val, duration, finalCall=false) {
    if (val == lastPublishTick) {
        return;
    }
    if (tickStatus != null) {
        let now = new Date().valueOf();
        if (now >= tickStatus["reload"]) {
            tickStatus = null;
            loadTick();
        } else if ((finalCall && now <= tickStatus["ignore"]) || (now >= tickStatus["update"] && Math.abs(val - tickStatus["last"]) >= (tickStatus["rate_sec"] / 2))) {
            lastPublishTick = val;
            tickStatus["last"] = val;
            tickStatus["update"] = now + tickStatus["rate_sec"] * 1000;
            tickStatus["ignore"] = now + 300 * 1000;
            fetch(tickStatus["url"], {
                keepalive: finalCall,
                method: 'PUT',
                headers: {
                    'Content-type': ''
                },
                body: JSON.stringify({
                    'id': selfID, 
                    at: parseFloat(val.toFixed(2)), 
                    dur: parseFloat(duration.toFixed(2)),
                    update: new Date(now).toISOString(),
                }),
            }).catch(e => { });
        }
    }
}

window.addEventListener("beforeunload", function(e){
    publishTick(player.currentTime, player.duration, true);
});

async function decodeData(value) {
    if(value==" "){return [[-1,""]];}
    const b64toBlob = (base64, type = 'application/octet-stream') => 
        fetch(`data:${type};base64,${base64}`).then(res => res.blob());
    const blob = await b64toBlob(value);
    const ds = new DecompressionStream("gzip");
    const decomp = blob.stream().pipeThrough(ds);
    const decoded = await new Response(decomp).blob();
    const text = await decoded.text();
    const parsed = JSON.parse(text);
    if ('word' in parsed) {
        parsed['word'] = parsed['word'].split("|");
    }
    return parsed;
}

function scrollDetected(event) { 
    pauseScroll = Date.now() + 10000;
}

document.addEventListener("DOMContentLoaded", function(event) {
    window.history.replaceState({}, null, window.location.href.split("?")[0].split("#")[0]);

    const events = ['touchstart', 'wheel'];
    events.forEach(event => {
        document.addEventListener(event, scrollDetected, { passive: true });
    });

    if (meta['dur'] !== null) {
        document.getElementById("pos").max = meta['dur'] * 10;
        posChanging(false);
    }

    player = document.getElementById('player');
    player.newTarget = null;

    loadTick();

    let targetPos = null;
    
    if (targetPos === null) {
        try {
            let temp = getParam("start");
            if (temp !== null && temp.length > 0) {
                targetPos = parseFloat(temp) / 10;
            }
        } catch (e) { }
    }
    if (targetPos === null) {
        try {
            let temp = urlHash;
            if (temp.length > 1) {
                targetPos = parseFloat(temp.substr(1)) / 10;
            }
        } catch (e) { }
    }
    if (targetPos === null) {
        try {
            let tempID = window.localStorage.getItem(meta['id']), 
                tempPos = window.localStorage.getItem('pos');
            if (tempID == meta['id']) {
                tempPos = parseFloat(tempPos);
                tempPos -= 5;
                if (tempPos > 0) {
                    targetPos = tempPos;
                }
            }
        } catch (e) { }
    }

    player.addEventListener("loadedmetadata", function() {
        playerLoaded();
        if (targetPos !== null) {
            player.currentTime = targetPos;
        }
    });
    player.addEventListener("loadeddata", function() {
        playerLoaded();
    });
    player.addEventListener("timeupdate", function () {
        let at = player.currentTime;
        publishTick(at, player.duration);
        if (player.paused == playerIsPlaying) {
            player.dispatchEvent(new CustomEvent(player.paused ? 'pause' : 'play'));
        }
        if (!isUserMoving) {
            document.getElementById("pos").value = at * 10;
            posChanging();
        }
        let lastElem = null, 
            highlightTime = 1.0 * player.playbackRate;

        if (lastHighlighted !== null) {
            if (at >= lastHighlighted[0].at && at < lastHighlighted[lastHighlighted.length-1].atEnd) {
                lastElem = lastHighlighted[0];
            } else if (lastHighlighted[lastHighlighted.length-1].hasOwnProperty("next")) {
                let started = lastHighlighted[lastHighlighted.length-1].next, ended = started;

                while (true) {
                    if (at >= started.at && at < ended.atEnd) {
                        lastElem = started;
                        break;
                    }
                    if (ended.atEnd - started.at > highlightTime) {
                        break;
                    }
                    if (ended.hasOwnProperty("next")) {
                        ended = ended.next;
                    } else {
                        break;
                    }
                }
            }
        }
        if (lastElem === null) {
            lastElem = bisect(byTime, e => e.at <= at, false);
        }

        let isIn = false;
        if (lastElem !== null && lastHighlighted !== null) {
            lastHighlighted.forEach((e) => {
                if (e === lastElem) {
                    isIn = true;
                }
            });
        }
        if (lastElem !== null && (lastHighlighted === null || (lastHighlighted !== null && !isIn))) {
            if (at >= 60) {
                window.localStorage.setItem('wordID', meta['id']);
                window.localStorage.setItem('pos', at);
            }
            let stack = [lastElem];
            lastElem.className = 'current';
            while ((stack[stack.length-1].atEnd - stack[0].at) <= highlightTime && stack[stack.length-1].hasOwnProperty("next")) {
                stack[stack.length-1].next.className = 'current';
                stack.push(stack[stack.length-1].next);
            }
            if (stack.length == 1) {
                stack[0].className = 'current left right';
            } else {
                stack[0].className = 'current left';
                stack[stack.length - 1].className = 'current right';
            }
            stack.forEach((e) => {
                e.className += e.isDiff ? ' diff': '';
            });
            if (autoScroll) {
                if (Date.now() > pauseScroll) {
                    stack[stack.length-1].scrollIntoView({
                        "block": "nearest",
                        "behavior": "smooth",
                    });
                }
            }
            if (lastHighlighted !== null) {
                lastHighlighted.forEach((e) => {
                    e.className = 'word' + (e.isDiff ? ' diff' : '');
                    e.para.className = '';
                });
            }
            stack.forEach((e) => {
                e.para.className = 'current';
            });
            lastHighlighted = stack;
        }
    }, false);

    player.addEventListener('play', function () {
        if (!playerIsPlaying) {
            document.getElementById("playButton").className.baseVal = "playPause pause";
            playerIsPlaying = true;
            turnOnWakeLock();
            if ('audioSession' in navigator) {
                const as = navigator.audioSession;
                if (as) {
                    as.type = 'playback';
                }
            }
        }
    });

    player.addEventListener('pause', function () {
        if (playerIsPlaying) {
            document.getElementById("playButton").className.baseVal = "playPause play";
            playerIsPlaying = false;
            turnOffWakeLock();
        }
    });

    decodeData(meta['segs']).then((segs) => {
        meta['segs'] = [...segs];
        if (segs.length > 1) {
            document.getElementById('segLink').style.display = "block";
        }
        decodeData(meta['words']).then((words) => {
            if (words.hasOwnProperty('timing')) {
                timing = [];

                document.addEventListener('mouseup', e => {
                    let sel = document.getSelection();
                    let picker = document.getElementById("picker");
                    let show = false;
                    if (sel.rangeCount > 0 && sel.toString().length > 0) {
                        if (sel.type == "Range") {
                            let tempLastSelFrom = sel.anchorNode;
                            let tempLastSelTo = sel.focusNode;
                            let nodeFrom = nearestNode(tempLastSelFrom, 'wordID', "next");
                            let nodeTo = nearestNode(tempLastSelTo, 'wordID', "prev");
                            if (nodeFrom != null && nodeTo != null) {
                                show = true;
                                lastSelFrom = tempLastSelFrom;
                                lastSelTo = tempLastSelTo;
                            }
                        }
                    }
                    if (show) {
                        ignoreSelChange = true;
                        let range = sel.getRangeAt(0).cloneRange();
                        let rect = range.getBoundingClientRect();
                        rect.left += window.scrollX;
                        rect.right += window.scrollX;
                        rect.top += window.scrollY;
                        rect.bottom += window.scrollY;

                        picker.style.display = 'block';
                        picker.style.top = (rect.top - picker.offsetHeight - 10) + "px";	
                        picker.style.left = ((rect.left + rect.right) / 2 - picker.offsetWidth / 2) + "px";  
                    } else {
                        if (ignoreSelChange) {
                            return;
                        }
                        picker.style.display = 'none';
                    }
                });

                document.addEventListener('mousedown', e => {
                    let sel = document.getSelection();
                    let picker = document.getElementById("picker");
                    if (sel.rangeCount == 0 || sel.toString().length == 0) {
                        if (ignoreSelChange) {
                            return;
                        }
                        setTimeout(() => {
                            picker.style.display = 'none';
                        }, 100);
                    }
                });

                document.addEventListener("selectionchange", e => {
                    let sel = document.getSelection();
                    let picker = document.getElementById("picker");

                    if (sel.rangeCount == 0 || sel.toString() == 0) {
                        if (ignoreSelChange) {
                            return;
                        }
                        setTimeout(() => {
                            picker.style.display = 'none';
                        }, 100);
                    }
                });
            }
            let children = [], lastPara = null, lastAt = 0, lastHeader = 0, lastSpeakerID=' ', lastEndAt = 0, lastTiming = 0, segSection = null, tempParas = [];
            for (let i = 0; i < words['word'].length; i++) {
                if (timing !== null) {
                    let temp = words['timing'][i * 2];
                    if (temp == -1) {
                        timing.push(0);
                    } else {
                        lastTiming += temp;
                        timing.push(lastTiming);
                    }
                    temp = words['timing'][i * 2 + 1];
                    if (temp == -1) {
                        timing.push(0);
                    } else {
                        lastTiming += temp;
                        timing.push(lastTiming);
                    }
                }
                let at = words['off'][i], word = words['word'][i], para = words['para'].charAt(i), speakerID = words['speaker'].charAt(i);
                at += lastAt;
                lastAt = at;
                at /= 100;
                if (paras.length == 0 || para == '.') {
                    lastPara = document.createElement("p");
                    tempParas.push(lastPara);
                    lastPara.segment = false;
                    lastPara.i = paras.length;
                    lastPara.at = at;
                    lastPara.atEnd = at;
                    let temp = document.createElement("span");
                    temp.className = "timecode";
                    temp.appendChild(document.createTextNode(getTick(at) + ":"));
                    lastPara.appendChild(temp);
                    paras.push(lastPara);
                }
                lastPara.children[lastPara.children.length-1].textContent += ' ';
                lastPara.atEnd = at;

                let temp = document.createElement("span");
                if (byTime.length > 0) {
                    byTime[byTime.length - 1].atEnd = at;
                    byTime[byTime.length - 1].next = temp;
                }
                temp.at = at;
                temp.wordID = i;
                temp.onclick = move;
                temp.className = "word";
                if (para == '.' && speakerID != lastSpeakerID) {
                    if (speakerID != ' ') {
                        let speaker = document.createElement("span");
                        speaker.textContent = speakerID + ": ";
                        speaker.className = "speaker";
                        lastPara.appendChild(speaker);
                    }
                    lastSpeakerID = speakerID;
                }
                if (speakerID != lastSpeakerID) {
                    temp.className += " diff";
                    temp.isDiff = true;
                } else {
                    temp.isDiff = false;
                }
                temp.appendChild(document.createTextNode(word));
                temp.para = lastPara;
                lastPara.appendChild(temp);
                byTime.push(temp);
            };
            if (byTime.length > 0) {
                byTime[byTime.length - 1].atEnd = (lastAt/100) + 3600;
            }

            segSection = document.createElement("div");
            stackPos = 1000;
            segSection.style.zIndex = stackPos;
            stackPos++;
            children.push(segSection);
            for (let curPara of tempParas) {
                if (segs[0][0] >= 0 && segs[0][0]/100 <= curPara.at) {
                    curPara.segment = true;
                    segSection = document.createElement("div");
                    segSection.style.zIndex = stackPos;
                    stackPos++;
                    segSection.className = "segment";
                    children.push(segSection);
                    let seg = document.createElement("p");
                    seg.className = "segment";
                    seg.appendChild(document.createTextNode(segs[0][1]));
                    segSection.appendChild(seg);

                    seg = document.createElement("span");
                    seg.className = "util";
                    seg.appendChild(document.createTextNode(segs[0][1]));
                    seg.onclick = ((x) => {return (() => {hideDrop();move(x);});})(curPara.at);
                    document.getElementById('dropdown_segs').appendChild(seg);

                    segs.shift();
                }
                segSection.appendChild(curPara);
            }

            document.getElementById("pos").max = (lastAt/100) * 10;
            document.getElementById("transcript").append(...children);

            let hidden, visibilityChange;
            if (typeof document.hidden !== "undefined") {
                hidden = "hidden";
                visibilityChange = "visibilitychange";
            } else if (typeof document.msHidden !== "undefined") {
                hidden = "msHidden";
                visibilityChange = "msvisibilitychange";
            } else if (typeof document.webkitHidden !== "undefined") {
                hidden = "webkitHidden";
                visibilityChange = "webkitvisibilitychange";
            }

            function pageAwake() {
                if (wakeLock !== null) {
                    wakeLock = null;
                    turnOnWakeLock();
                }
                if (lastHighlighted !== null && autoScroll && lastHighlighted.length > 0) {
                    lastHighlighted[lastHighlighted.length-1].scrollIntoView({
                        "block": "nearest",
                        "behavior": "smooth",
                    });
                }
            }
            document.addEventListener(visibilityChange, () => { 
                if (!document[hidden]) {
                    pageAwake();
                }
            });
            document.addEventListener('pageshow', pageAwake);
            document.addEventListener('focus', pageAwake);
            document.addEventListener('scroll', updateScrolls);
            window.addEventListener('blur', windowBlur);
            setupWakeLock();
            playerLoaded();

            extraSetup();
        });
    });
});
extraScript();
/* --- Minify End --- */
</script>
</head>
<body>
<div class="rows header">
    <svg id="playButton" class="playPause play" width="50" height="50" id="btnPlay" viewBox="-2 -2 108 108" onclick="play()">
        <circle class="forPlay" cx="51" cy="51" r="50" style="stroke-width:1px;stroke:light-dark(#fff,#000);fill:light-dark(#fff,#000);" />
        <line class="forPlay" x1="38" y1="30" x2="38" y2="70" style="stroke-width:8px;stroke:light-dark(#004,#bbf);stroke-linecap:round;" />
        <path class="forPlay" d="M 38 30 L 70 50 L 38 70" rx="10" ry="10" style="stroke-width:8px;stroke:light-dark(#004,#bbf);fill:light-dark(#004,#bbf);stroke-linejoin:round;stroke-linecap:round;" />
        <circle class="forPause" cx="51" cy="51" r="50" style="stroke-width:5px;stroke:light-dark(#004,#bbf);fill:light-dark(#fff,#000);" />
        <line class="forPause" x1="38" y1="30" x2="38" y2="70" style="stroke-width:8px;stroke:light-dark(#004,#bbf);stroke-linecap:round;" />
        <path class="forPause" d="M 66 30 L 66 50 L 66 70" rx="10" ry="10" style="stroke-width:8px;stroke:light-dark(#004,#bbf);fill:light-dark(#004,#bbf);stroke-linejoin:round;stroke-linecap:round;" />
    </svg>
    <input class="slider fill" type="range" min="0" max="1000" value="0" id="pos" onchange="posChange()" oninput="posChanging()" onmousedown="posMoving()" onmouseup="posMoved()">
    <span id="posText"><span id="posCurrent">0:00:00</span><br><font size="-1">-<span id="posLeft">0:00:00</span></font></span>
    <span class="link">
        <svg fill="light-dark(#004,#bbf)" stle="width:50px" viewBox="-5 -5 70 70" width="24" height="24" onclick="showLinks()" xmlns="http://www.w3.org/2000/svg" fill-rule="evenodd" clip-rule="evenodd">
            <g transform="matrix(1,0,0,1,-1088,-192)">
                <g>
                    <g transform="matrix(1.50868,0,0,1.01217,70.647,191.772)">
                        <g transform="matrix(0.149202,0,0,0.173437,664.206,42.142)">
                            <rect x="103.288" y="8.535" width="71.218" height="34.133" style="fill-rule:nonzero;"/>
                        </g>
                        <g transform="matrix(0.149202,0,0,0.173437,664.345,27.4)">
                            <rect x="103.288" y="8.535" width="141.366" height="34.133" style="fill-rule:nonzero;"/>
                        </g>
                        <g transform="matrix(0.149202,0,0,0.173437,664.345,12.658)">
                            <rect x="103.288" y="8.535" width="212.447" height="34.133" style="fill-rule:nonzero;"/>
                        </g>
                    </g>
                </g>
            </g>
        </svg>
    </span>
    <!-- EXTRA_WIDGETS -->
</div>

<div class="content" id="transcript"></div>
<div class="overlay hidden" id="overlay" onclick="hideDrop()"></div>
<div class="dropdown hidden" id="setpos">
    Set position:
    <form action="" onsubmit="return posSelected(event);">
        <input type="text" size="8" autocomplete="off" autocorrect="off" id="enteredPos" inputmode="decimal" value="0:00:00">
        <input type="submit" value="Jump">
    </form>
</div>
<div class="dropdown hidden" id="dropdown_segs">
</div>
<div class="dropdown hidden" id="dropdown">
    <span class="util" onclick="getLink();">Copy link...</span>
    <span class="util" onclick="showSegs();" id="segLink" style="display:none;">Segments...</span>
    <span class="util" onclick="showPos()" title="Ctrl-S">Set position...</span>
    Options:<br>
    <div style="padding-left: 1em;">
        <span class="util sel" id="click_to_jump" onclick="onClickToJump()">Jump on click</span>
        <span class="util sel" id="auto_scroll" onclick="onAutoScroll()">Auto scroll</span>
    </div>
    Playback speed:<br>
    <div style="padding-left: 1em;">
        <span class="util nosel" id="speed_0_5" onclick="setSpeed(0.5, '0_5')">0.50x</span>
        <span class="util sel" id="speed_1_0" onclick="setSpeed(1, '1_0')">1.00x</span>
        <span class="util nosel" id="speed_1_25" onclick="setSpeed(1.25, '1_25')">1.25x</span>
        <span class="util nosel" id="speed_1_5" onclick="setSpeed(1.5, '1_5')">1.50x</span>
        <span class="util nosel" id="speed_1_75" onclick="setSpeed(1.75, '1_75')">1.75x</span>
        <span class="util nosel" id="speed_2_0" onclick="setSpeed(2, '2_0')">2.00x</span>
        <span class="util nosel" id="speed_2_5" onclick="setSpeed(2.5, '2_5')">2.50x</span>
        <span class="util nosel" id="speed_3_0" onclick="setSpeed(3, '3_0')">3.00x</span>
    </div>
    Font size:<br>
    <div style="padding-left: 1em;">
        <span class="util sel" id="size_100" onclick="setSize(100, '100')">100%</span>
        <span class="util nosel" id="size_125" onclick="setSize(125, '125')">125%</span>
        <span class="util nosel" id="size_150" onclick="setSize(150, '150')">150%</span>
        <span class="util nosel" id="size_200" onclick="setSize(200, '200')">200%</span>
    </div>
</div>

<span id="picker" class="picker">
    <span onmousedown="downloadSel(true, event)" id="preview">Preview</span> or <span onmousedown="downloadSel(false, event)">download</span> segment | 
    <span onmousedown="copySel()">Copy text</span><br>
    Pad: Before <input type="text" id="padBefore", value="0" size="4">, After: <input type="text" id="padAfter", value="0" size="4"><br>
    <span onmousedown="closeSel()" style="float:right;">Close</span>
</span>
<audio id="player" preload="metadata"><source src="[[MP3_NAME]]"></audio>

</body>
</html>
