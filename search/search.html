<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="icon" type="image/png" sizes="16x16" href="spyglass.png"/>
<title><!-- search_title --></title>
<style>
:root{
    color-scheme: light dark;

    --bg-color:light-dark(#ededed, #121212);
    --card-color:light-dark(#e1e1e1, #1e1e1e);
    --text-color:light-dark(#1f1f1f, #e0e0e0);
    --accent-text:light-dark(#ffffff, #000000);
    --accent-color:light-dark(#00005f, #a0a0ff);
    --accent-hover:light-dark(#00003f, #c0c0ff);
    --border-color:light-dark(#cccccc, #333333);
    --secondary-color:light-dark(#d2d2d2, #2d2d2d);
    --error-color:light-dark(#993043, #cf6679);
    --highlight-color:light-dark(#ffffff, #ffffff);
    --highlight-background:light-dark(#3f3fbf, #4040c0);
}
*{
    margin:0;
    padding:0;
    box-sizing:border-box;
    font-family:"Roboto",sans-serif;
    font-size:12pt;
}
.segment{
    background-color: light-dark(#bbb, #444);
    padding: 6px;
    margin-bottom: 1em;
}
.clickable{
    cursor:pointer;
    color:var(--accent-color);
}
.clickable:hover{
    text-decoration:underline;
}
.target{
    background-color:var(--highlight-background);
    color:var(--highlight-color);
    box-shadow: 0.5ch 0.25ch var(--highlight-background), 0.5ch -0.25ch var(--highlight-background), -0.5ch 0.25ch var(--highlight-background), -0.5ch -0.25ch var(--highlight-background);
}
body{
    background-color:var(--bg-color);
    color:var(--text-color);
    min-height:100vh;
    display:flex;
    flex-direction:column;
    align-items:center;
    padding:2rem;
}
.created{
    font-size:8pt;
    padding-top:0.25em;
}
.created span{
    font-size:8pt;
}
.container{
    width:100%;
}
header{
    margin-bottom:2rem;
    text-align:center;
}
.page-title {
    display: flex;
    align-items: center;
    justify-content: center;
    margin-bottom: 1rem;
}
.title-text p {
    font-size: 1rem;
    color: var(--text-color);
    opacity: 0.8;
    font-weight: 400;
}
h1{
    font-size:2.5rem;
    margin-bottom:0.5rem;
    color:var(--accent-color);
}
.search-card{
    background-color:var(--card-color);
    border-radius:8px;
    padding:2rem;
    box-shadow:0 4px 6px rgba(0,0,0,0.1);
    margin-bottom:2rem;
}
.search-form{
    display:flex;
    flex-direction:column;
    gap:1.2rem;
}
.search-bar {
    display:flex;
    gap:0.5rem;
}
.search-style {
    width:auto;
    flex:0 0 auto;
}
input[type=checkbox]:disabled {
  opacity: 0.25;
  cursor: not-allowed;
}
input[type=checkbox]:disabled+label{
    opacity: 0.25;
    cursor: not-allowed;
}
input[type="text"],select{
    flex:1;
    padding:0.75rem 1rem;
    font-size:1rem;
    background-color:var(--secondary-color);
    color:var(--text-color);
    border:1px solid var(--border-color);
    border-radius:4px;
    outline:none;
    transition:border-color 0.3s;
}
input[type="text"]:focus,select:focus {
    border-color:var(--accent-color);
}
select{
    cursor:pointer;
    appearance:none;
    padding-right:2rem;
    background-image:url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23e0e0e0' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
    background-repeat:no-repeat;
    background-position:right 0.7rem center;
    background-size:1rem;
}
button{
    padding:0.75rem 1.5rem;
    font-size:1rem;
    background-color:var(--accent-color);
    color:var(--accent-text);
    border:none;
    border-radius:4px;
    cursor:pointer;
    transition:background-color 0.3s;
}
button:hover{
    background-color:var(--accent-hover);
}
.search-options{
    display:flex;
    flex-wrap:wrap;
    gap:1.5rem;
}
.option-group{
    min-width:200px;
}
.option-label{
    font-size:0.9rem;
    font-weight:600;
    margin-bottom:0.5rem;
    display:block;
    color:var(--accent-color);
}
.time-inputs{
    display:flex;
    gap:1rem;
}
.time-input{
    flex:1;
}
.time-input input{
    width:10em;
}
.checkbox-group{
    display:flex;
    align-items:center;
    gap:0.5rem;
    margin-top:0.5rem;
}
input[type="checkbox"]{
    appearance:none;
    width:18px;
    height:18px;
    border:2px solid var(--border-color);
    border-radius:3px;
    background-color:var(--secondary-color);
    cursor:pointer;
    position:relative;
}
input[type="checkbox"]:checked{
    background-color:var(--accent-color);
    border-color:var(--accent-color);
}
input[type="checkbox"]:checked::after{
    content:"";
    position:absolute;
    left:5px;
    top:2px;
    width:5px;
    height:10px;
    border:solid var(--accent-text);
    border-width:0 2px 2px 0;
    transform:rotate(45deg);
}
.results-container{
    background-color:var(--card-color);
    border-radius:8px;
    padding:1.5rem;
    box-shadow:0 4px 6px rgba(0,0,0,0.1);
}
.results-header{
    display:flex;
    justify-content:space-between;
    align-items:center;
    margin-bottom:1.5rem;
    padding-bottom:0.75rem;
    border-bottom:1px solid var(--border-color);
}
.result-stats{
    font-size:0.9rem;
    color:var(--text-color);
}
.result-sort{
    display:flex;
    align-items:center;
    gap:0.5rem;
}
.result-sort select{
    padding:0.5rem;
    font-size:0.9rem;
}
.result-item{
    padding:1.2rem;
    border-bottom:1px solid var(--border-color);
}
.result-item:last-child{
    border-bottom:none;
}
.result-title{
    font-size:1.2rem;
    margin-bottom:0.5rem;
    color:var(--accent-color);
}
.result-title a{
    color:var(--accent-color);
    text-decoration:none;
}
.result-title a:hover{
    text-decoration:underline;
}
.result-description{
    font-size:0.95rem;
    line-height:1.5;
}
.pagination{
    display:flex;
    justify-content:center;
    margin-top:2rem;
    gap:0.5rem;
}
.page-btn{
    padding:0.5rem 1rem;
    background-color:var(--secondary-color);
    color:var(--text-color);
    border:1px solid var(--border-color);
    border-radius:4px;
    cursor:pointer;
    transition:all 0.3s;
}
.page-btn:hover:not(.active){
    background-color:light-dark(#ccc, #333);
}
.page-btn.active{
    background-color:var(--accent-color);
    border-color:var(--accent-color);
    color:var(--accent-text);
}
.quick-links{
    display:flex;
    gap:1.5rem;
    margin-top:1.2rem;
}
.quick-link{
    color:var(--accent-color);
    text-decoration:none;
    font-size:0.95rem;
    position:relative;
    transition:color 0.2s;
}
.quick-link:hover{
    color:var(--accent-hover);
    text-decoration:underline;
}
.quick-link::after{
    content:"\2192";
    position:relative;
    display:inline-block;
    margin-left:4px;
    transition:transform 0.2s;
}
.quick-link:hover::after{
    transform:translateX(3px);
}
.hit{
    margin-bottom:0.5em;
    line-height:125%;
    text-indent:-2em;
    margin-left:2em;
}
@media(max-width:768px){
    body{
        padding:0.5rem;
    }
    .page-title {
        flex-direction: column;
        gap: 0.75rem;
        padding: 1rem 0;
    }
    .search-bar{
        flex-direction:column;
    }
    .search-options{
        flex-direction:column;
        gap:1rem;
    }
    .option-group{
        width:100%;
    }
    .search-card,.results-container{
        border-radius:4px;
        padding:1rem;
    }
    .result-item{
        padding:0.8rem;
    }
    .search-form{
        gap:0.8rem;
    }
    .hit{
        text-indent:-1em;
        margin-left:1em;
    }
}
</style>
<script>
let contextBefore = 5;
let contextAfter = 500;
let totalItems = 0;
let info = null;
let batches = null;
let batchData = {};
let pages = {'terms': '', 'pages': []};

async function fetchWithRetry(url, start, len) {
    const isChrome = navigator.userAgent.toLowerCase().includes('chrome');
    if (!isChrome) {
        /* FireFox is silly, so be silly in response */
        const resp = await fetch(url);
        if (!resp.ok) {
            throw new Error(`HTTP error! status: ${resp.status}`);
        }
        const fullBlob = await resp.blob();
        const endByte = Math.min(start + len, fullBlob.size);
        const subsetBlob = fullBlob.slice(start, endByte);
        return subsetBlob;
    }
  
    const chunks = [];
    let currentStart = start;
    let remainingBytes = len;
  
    while (remainingBytes > 0) {
        const chunkEnd = currentStart + remainingBytes - 1;
        const resp = await fetch(
            url,
            {
                'headers': {
                    'Range': `bytes=${currentStart}-${chunkEnd}`,
                },
            }
        );
        if (!resp.ok) {
            throw new Error(`HTTP error! status: ${resp.status}`);
        }
        const chunk = await resp.blob();
        if (chunk.size === 0) {
            throw new Error(`Request returned 0 bytes for range ${currentStart}-${chunkEnd}`);
        }
    
        chunks.push(chunk);
        const bytesReceived = chunk.size;
        currentStart += bytesReceived;
        remainingBytes -= bytesReceived;
    }
    return new Blob(chunks);
}

async function getData(data_num, start, len, loadMode='gzipDecode') {
    let resp;
    if (Number.isFinite(data_num)) {
        const url = "./search_data_" + String(data_num).padStart(2, '0') + ".dat";
        data = await fetchWithRetry(url, start, len);
    } else {
        resp = await fetch("./search_data_" + data_num + ".dat");
        data = await resp.blob();
    }

    if (loadMode == 'gzipDecode') {
        const ds = new DecompressionStream("gzip");
        const decomp = data.stream().pipeThrough(ds);
        const decoded = await new Response(decomp).blob();
        const text = await decoded.text();
        const parsed = JSON.parse(text);
        return parsed;
    } else if (loadMode == 'json') {
        const text = await data.text();
        const parsed = JSON.parse(text);
        return parsed;
    }
}

function escapeRe(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

async function cacheLoad(batchInfo) {
    let key = batchInfo.join('|');
    if (!(key in batchData)) {
        batchData[key] = await getData(...batchInfo);
    }
    return batchData[key];
}

function showHit(item, search, showAll, batch, itemID, paginator, countOnly) {
    let ret = [];
    let lastHit = 0;
    
    let findHits = handler => {
        let words = item[search.title ? 'title' : 'words'].toLowerCase();
        let parseItem = true;

        if (search.hasOwnProperty("groups") && search.groups.length > 0) {
            parseItem = false;
            for (let x of search.groups) {
                if (x == item['group']) {
                    parseItem = true;
                }
            }
        }

        if (parseItem) {
            if (showAll || (search.title && search.terms.join(' ').length == 0)) {
                handler(0, 0);
            } else if (search.regex) {
                let target = search.terms.join(' ');
                target = new RegExp(target, 'gi');
                while (true) {
                    let hit = target.exec(words);
                    if (hit == null) {
                        break;
                    }
                    if (!handler(hit.index, hit[0].length)) {
                        break;
                    }
                }
            } else if (search.logic) {
                let lastHit = -1;
                while (true) {
                    let temp = search.logicFunc(words.slice(lastHit + 1));
                    if (!temp[0]) {
                        break;
                    }
                    if (!handler(lastHit + 1 + temp[1], temp[2] - temp[1] + 1)) {
                        break;
                    }
                    lastHit += temp[2];
                }
            } else {
                let target = search.terms.join(' ');
                target = target.split('').map(x=>escapeRe(x)+'-?').join('');
                target = RegExp(target, 'gi');
                while (true) {
                    let hit = target.exec(words);
                    if (hit == null) {
                        break;
                    }
                    if (!handler(hit.index, hit[0].length)) {
                        break;
                    }
                }
            }
        }
    };

    let lookup = null;
    let start = null;
    let speaker = null;
    let speakerPop = null;
    let counts = null;
    let hitCounts = [];

    let extra = '';
    if (window.location.hash.substring(1, 5) == "rid=") {
        extra = atob(window.location.hash.substring(5));
    }

    let showHit = (hitAt, hitLen) => {
        if (paginator.skip > 0) {
            paginator.skip--;
        } else if (countOnly) {
            paginator.bail--;
            paginator.found++;
            hitCounts.push(0);
            if (hitCounts.length == 1) {
                paginator.foundTitles++;
            }
        } else {
            let hit = document.createElement("div");
            if (!search.title) {
                hit.className = "result-item";
            }
            ret.push(hit);

            let header = document.createElement("h3");
            header.className = "result-title";
            hit.appendChild(header);

            let link = document.createElement("a");
            header.appendChild(link);
            link.href = item.link;
            link.target = "_blank";
            link.innerText = (item.published == '1970-01-01' ? '' : (item.published + ": ")) + item.title;

            let info = document.createElement("p");
            info.className = "result-description";
            hit.appendChild(info);

            if (batch !== null) {
                let span = document.createElement("span");
                header.appendChild(span);
                span.innerText = " ";
                let fullLink = document.createElement("a");
                header.appendChild(fullLink);
                let count = document.createElement("span");
                header.appendChild(count);
                hitCounts.push(count);
                if (hitCounts.length == 1) {
                    paginator.foundTitles++;
                }
                fullLink.className = "transcriptLink";
                fullLink.innerText = "[transcript]";
                fullLink.target = "_blank";
                if (extra.length > 0 && 'remote' in item) { 
                    fullLink.href = extra + item.remote.split("\t")[0] + ".html";
                    if (!search.title) {
                        fullLink.href += "#" + start[hitAt] * 10;
                    }
                } else {
                    fullLink.href = "#" + batch[0] + "," + batch[1] + "," + batch[2] + "," + itemID;
                    if (!search.title) {
                        fullLink.href += "," + start[hitAt];
                    }
                }
            }
            
            if (!search.title) {
                let lastSpeaker = '';
                let phraseStartAt = 0;
                let startAt = -1;
                let phrase = null;
                let endedSentence = false;
                let segments = [];
                if (showAll) {
                    if (item.hasOwnProperty("segments")) {
                        for (let i = 0; i < item.segments.title.length; i++) {
                            segments.push([item.segments.offset[i], item.segments.title[i]]);
                        }
                    }
                }
                for (let i = Math.max(0, hitAt - contextBefore); i <= (showAll ? (start.length - 1) : Math.min(hitAt + 1 + contextAfter, start.length - 1)); i++) {
                    if (!showAll) {
                        if (startAt >= 0 && ((start[i] / 100) - startAt) > 60) {
                            break;
                        }
                    }
                    let curSpeaker = "";
                    if (phrase === null || (endedSentence && (lastSpeaker != speaker[i] || (start[i] - phraseStartAt) >= 45)) || (start[i] - phraseStartAt) >= 120) {
                        if (lastSpeaker != speaker[i]) {
                            curSpeaker = speakerPop[speaker[i]];
                        }
                        lastSpeaker = speaker[i];
                        phraseStartAt = start[i];
                        if (startAt === -1) {
                            startAt = phraseStartAt;
                        }
                        
                        let segmentTitle = null;
                        while (segments.length > 0 && segments[0][0] <= phraseStartAt) {
                            segmentTitle = segments.shift()[1];
                        }
                        if (segmentTitle != null) {
                            let text = document.createElement("p");
                            text.className = "segment";
                            text.innerText = "Segment: " + segmentTitle;
                            hit.appendChild(text);
                        }


                        let text = document.createElement('p');
                        hit.appendChild(text);
                        text.className = "hit";
                        let time = document.createElement('span');
                        text.appendChild(time);
                        let at = start[i];
                        let val = "";
                        val += Math.floor(at / 3600).toString() + ":";
                        val += (Math.floor(at / 60) % 60).toString().padStart(2, "0") + ":";
                        val += (at % 60).toString().padStart(2, "0") + ":";
                        time.innerText = val;
                        phrase = document.createElement('span');
                        text.appendChild(phrase);
                    }

                    let curWord = item.words.slice(lookup.word[i], lookup.word[i+1]-1);
                    let wordElem = document.createElement('span');
                    wordElem.at = start[i];
                    if (!showAll) {
                        if (i >= hitAt && i <= hitLen) {
                            wordElem.className = "target";
                        }
                    }
                    if (curSpeaker.length > 0) {
                        phrase.appendChild(document.createTextNode(curSpeaker));
                    }
                    phrase.appendChild(document.createTextNode(" "));
                    wordElem.innerText = curWord;
                    phrase.appendChild(wordElem);
                    curSpeaker = "";
                    endedSentence = ".?!".includes(curWord.slice(-1));
                }
            }

            paginator.bail--;
            paginator.found++;
        }
        paginator.pos++;
        if (showAll) {
            return false;
        }
        if (paginator.bail == 0 && search.show_next) {
            return false;
        }
        return true;
    };

    findHits((hit, size) => {
        if (lookup == null) {
            lookup = {pos: [], word: []};
            if (!search.title) {
                let wordNum = -1;
                let off = 0;
                let wasSpace = true;
                for (let x of item.words) {
                    if (wasSpace) {
                        wordNum++;
                        lookup.word.push(off);
                    }
                    wasSpace = (x == ' ');
                    lookup.pos.push(wordNum);
                    off++;
                }
                lookup.word.push(off+1);

                let last = 0;
                start = [];
                for (let cur of item.start) {
                    last += cur;
                    start.push(last);
                }

                speakerPop = {};
                speaker = item.speaker.split('');
                counts = {};
                speaker.map(x => {
                    counts[x] = counts[x] ? counts[x] + 1 : 1;
                });
                counts["@"] = 0;
                counts = Object.entries(counts);
                counts.sort((a, b) => {
                    if (b < a) {
                        return -1;
                    }
                    if (a > b) {
                        return 1;
                    }
                    return 0;
                });
                counts.map(x => {
                    if (x[0] == "@") {
                        speakerPop[x[0]] = '';
                    } else {
                        speakerPop[x[0]] = ' ' + String.fromCharCode("A".charCodeAt(0) + Object.keys(speakerPop).length) + ": ";
                    }
                });
            }
        }

        if (!showHit(lookup.pos[hit], lookup.pos[hit+size])) {
            return false;
        }
        return true;
    });

    return ret;
}

async function showTranscript(data_num, start, len, itemID) {
    let batch = await getData(data_num, start, len);
    document.title = batch[itemID].title;
    let items = showHit(batch[itemID], '', true, null, null, {skip: 0, pos: 0, bail: 9999, found: 0});
    document.getElementById("results").replaceChildren(...items);
}

function notify(desc) {
    let searching = document.createElement('span');
    searching.innerText = desc;
    document.getElementById("results").replaceChildren(searching);
}

async function searchFor(search, skip=0, countOnly=false, showLatest=false, showAll=false) {
    if (info === null) {
        info = await getData(0, 0, 100, "json");
        batches = await getData(...info.data);
    }

    if (!countOnly) {
        notify("Searching...");
    }

    let searchTerms = search.split(' ');
    let paginator = {
        skip: skip, 
        pos: 0, 
        bail: countOnly ? 100000 : 100, 
        found: 0,
        foundTitles: 0,
    };
    search = {
        terms: [],
        before: null,
        after: null,
        regex: false,
        logic: false,
        title: false,
        reverse: false,
        groups: [],
        orig: search,
        show_next: true,
    };

    if (document.getElementById("start").value.length > 0) {
        search.after = document.getElementById("start").value;
    }

    if (document.getElementById("end").value.length > 0) {
        search.before = document.getElementById("end").value;
    }

    if (document.getElementById("search_type").value == "regex") {
        search.regex = true;
    } else if (document.getElementById("search_type").value == "logic") {
        search.logic = true;
    } else if (document.getElementById("search_type").value == "title") {
        search.title = true;
        document.getElementById("totalsCount").innerText = '';
    }

    if (document.getElementById("reverse").checked) {
        search.reverse = true;
    }

    if (document.getElementById("target_group") !== null) {
        if (document.getElementById("target_group").value != "") {
            search.groups.push(document.getElementById("target_group").value);
        }
    }

    for (let word of searchTerms) {
        search.terms.push(word);
    }

    if (!(search.regex || search.logic || search.title)) {
        if (document.getElementById('similar').checked) {
            let [complex, simple] = await cacheLoad(['lemma', 0, 0]);
            let fixed = [];
            for (let term of search.terms) {
                if (term in complex) {
                    term = complex[term];
                };
                let temp = [escapeRe(term)];
                if (term in simple) {
                    temp = temp.concat(simple[term]);
                }
                fixed.push(temp);
            }
            search.terms = [fixed.map(x => `(${x.join('|')})`).join(' ')];
            search.regex = true;
        }
    }

    if (showAll) {
        document.getElementById("totalsCount").innerText = '';
        search.title = true;
        search.terms = [];
        paginator.bail = 100000;
    } else if (showLatest) {
        document.getElementById("totalsCount").innerText = '';
        search.title = true;
        search.terms = [];
        if (search.reverse) {
            paginator.bail = 25;
            search.show_next = false;
        } else {
            paginator.skip = Math.max(0, totalItems - 25);
            paginator.bail = 10000;
        }
        search.after = null;
        search.before = null;
    } else if (search.logic) {
        let debugLogic = false;
        let nearAmount = 200;
        /* ########################################################################################################################################## */
        let terms = [];
        let state = {negate: false, new: true};
        let dumpState = termsToDump => {
            let termsPretty = [];
            for (let x of termsToDump) {
                if (x.oper == 'HIT') {
                    if (x.negate) {
                        termsPretty.push("!" + x.val);
                    } else {
                        termsPretty.push(x.val);
                    }
                } else {
                    termsPretty.push(x.oper);
                }
            };
            return termsPretty.join(" ");
        };
        if (debugLogic) {
            console.log(`  Stack: '${search.terms.join("', '")}'`);
        }
        let isWhole = false;
        for (let val of search.terms.join(' ').replace("(", " ( ").replace(")", " ) ").split(' ')) {
            if (val.length > 0) {
                if (val.search(/^(and|or|near)$/i) == 0) {
                    terms.push({oper: val.toUpperCase()});
                    state.new = true;
                } else if (val.search(/^(whole)$/i) == 0) {
                    isWhole = true;
                } else if (val == "(") {
                    terms.push({oper: "OPEN"});
                } else if (val == ")") {
                    terms.push({oper: "CLOSE"});
                } else if (val.search(/^(not)$/i) == 0) {
                    state.new = true;
                    state.negate = true;
                } else {
                    if (state.new) {
                        terms.push({whole: isWhole, oper: 'HIT', val: val, negate: state.negate});
                        state.new = false;
                        state.negate = false;
                    } else {
                        terms[terms.length-1].val += ' ' + val;
                    }
                }
            }
        };
        if (debugLogic) {
            console.log(`  Parsed: ${dumpState(terms)}`);
        }

        let hitOrVal = x => {
            /* Just see if an item is a hit or a val */
            return (x.oper == 'HIT') || (x.oper == 'VAL');
        };

        let isTrue = (x, words) => {
            /* See if an item is a True bool, or a hit that matches */
            if (x.oper == 'VAL') {
                return x.val;
            } else if (x.oper == 'HIT') {
                let ret;
                if (x.whole) {
                    ret = words.search(new RegExp("\\b" + x.val.replace(/[/\-\\^$*+?.()|[\]{}]/g, '\\$&') + "\\b")) >= 0;
                } else {
                    ret = (words.indexOf(x.val) >= 0);
                }
                if (x.negate) {
                    ret = !ret;
                }
                return ret;
            } else {
                throw new Error("Unable to parse syntax: " + JSON.stringify(x));
            }
        };

        let isWord = x => {
            /* See if an item is a positive hit */
            return x.oper == 'HIT' && !x.negate;
        };

        let range = (words, x, y, dest) => {
            /* Get extend of begin and end */

            if (x !== null) {
                if (x.oper == 'HIT' && x.begin == undefined && !x.negate) {
                    let temp = words.indexOf(x.val);
                    if (temp >= 0) {
                        x.begin = temp;
                        x.end = temp + x.val.length;
                    }
                }
            }

            if (y !== null) {
                if (y.oper == 'HIT' && y.begin == undefined && !y.negate) {
                    let temp = words.indexOf(y.val);
                    if (temp >= 0) {
                        y.begin = temp;
                        y.end = temp + y.val.length;
                    }
                }
            }

            if (x != null && y != null && x.begin != undefined && y.begin != undefined) {
                dest.begin = Math.min(x.begin, y.begin);
            } else if (x != null && x.begin != undefined) {
                dest.begin = x.begin;
            } else if (y != null && y.begin != undefined) {
                dest.begin = y.begin;
            }

            if (x != null && y != null && x.begin != undefined && y.begin != undefined) {
                dest.end = Math.max(x.end, y.end);
            } else if (x != null && x.begin != undefined) {
                dest.end = x.end;
            } else if (y != null && y.begin != undefined) {
                dest.end = y.end;
            }
        };

        let processTerms = (words, terms) => {
            let stack = [...terms];
            for (let cur of stack) {
                cur.begin = undefined;
                cur.end = undefined;
            }

            while (true) {
                /* Find and resolve parens */
                let foundPair = false;
                let depth = 0;
                let openAt = -1;
                let i = -1;
                for (let x of stack) {
                    i++;
                    if (x.oper == 'OPEN') {
                        if (depth == 0) {
                            openAt = i;
                        }
                        depth++;
                    } else if (x.oper == 'CLOSE') {
                        depth--;
                        if (depth == 0) {
                            /* Found an open and matching close, process the contents */
                            let temp = processTerms(words, stack.slice(openAt + 1, i));
                            stack = stack.slice(0, openAt).concat([{oper: 'VAL', val: temp[0], begin: temp[1], end: temp[2]}]).concat(stack.slice(i+1));
                            foundPair = true;
                            break;
                        }
                    }
                };
                if (!foundPair) {
                    break;
                }
            }
            while (stack.length > 1) {
                if (stack.length >= 3 && ((stack[0].oper == 'VAL' && !stack[0].val) || (stack[2].oper == 'VAL' && !stack[2].val)) && stack[1].oper == 'NEAR') {
                    /* x NEAR x, where one of the x is False */
                    stack = [{oper: 'VAL', val: false}].concat(stack.slice(3));
                } else if (stack.length >= 3 && stack[0].oper == 'HIT' && stack[1].oper == 'NEAR' && stack[2].oper == 'HIT') {
                    /* x NEAR x, where both of the x are hit */

                    let findMatch = (words, x, off) => {
                        if (stack[0].whole) {
                            let ret = words.slice(off).search(new RegExp("\\b" + x.replace(/[/\-\\^$*+?.()|[\]{}]/g, '\\$&') + "\\b"));
                            if (ret >= 0) {
                                return ret + off;
                            } else {
                                return ret;
                            }
                        } else {
                            return words.indexOf(x, off);
                        }
                    };

                    /* Find all the possible hits */
                    let locs = x => {
                        let ret = [];
                        let i = -1;
                        while ((i=findMatch(words,x,i+1)) >= 0) {
                            ret.push(i);
                        }
                        return ret;
                    };
                    let nears = 0;
                    let hits = [locs(stack[0].val)];
                    while (stack.length >= (2 * (nears + 1)) && stack[1 + nears * 2].oper == 'NEAR' && stack[2 + nears * 2].oper == 'HIT') {
                        hits.push(locs(stack[nears * 2 + 2].val));
                        nears++;
                    }
                    let allGood = true;
                    let pos = [];
                    for (let a of hits[0]) {
                        allGood = true;
                        pos = [a];
                        for (let other of hits.slice(1)) {
                            let found = false;
                            for (let b of other) {
                                if (Math.abs(a - b) <= nearAmount) {
                                    pos.push(b);
                                    found = true;
                                    break;
                                }
                            }
                            if (!found) {
                                allGood = false;
                                break;
                            }
                        }
                        if (allGood) {
                            break;
                        }
                    }
                    if (allGood) {
                        stack = [stack[0]].concat(stack.slice(2 * nears + 1));
                        stack[0].begin = Math.min(...pos);
                        stack[0].end = Math.max(...pos);
                    } else {
                        stack = [{oper: 'VAL', val: false}].concat(stack.slice(2 * nears + 1));
                    }

                } else if (stack.length >= 3 && hitOrVal(stack[0]) && stack[1].oper == 'AND' && hitOrVal(stack[2])) {
                    /* x AND x */
                    if (isTrue(stack[0], words) && isTrue(stack[2], words) && isWord(stack[0]) && isWord(stack[2])) {
                        range(words, stack[0], stack[2], stack[0]);
                        stack = [stack[0]].concat(stack.slice(3));
                    } else {
                        let temp = {};
                        range(words, stack[0], stack[2], temp);
                        stack = [{oper: 'VAL', val: isTrue(stack[0], words) && isTrue(stack[2], words)}].concat(stack.slice(3));
                        range(words, temp, temp, stack[0]);
                    }
                } else if (stack.length >= 3 && hitOrVal(stack[0]) && stack[1].oper == 'OR' && hitOrVal(stack[2])) {
                    /* x OR x */
                    if ((isTrue(stack[0], words) || isTrue(stack[2], words)) && isWord(stack[0]) && isWord(stack[2])) {
                        if (isTrue(stack[0], words)) {
                            stack = [stack[0]].concat(stack.slice(3));
                        } else {
                            stack = [stack[2]].concat(stack.slice(3));
                        }
                    } else {
                        stack = [{oper: 'VAL', val: isTrue(stack[0], words) || isTrue(stack[2], words)}].concat(stack.slice(3));
                    }
                } else {
                    throw new Error("Invalid operator: " + dumpState(stack));
                }
            }

            if (stack.length == 1 && hitOrVal(stack[0])) {
                range(words, stack[0], stack[0], stack[0]);
                return [isTrue(stack[0], words), stack[0].begin, stack[0].end];
            } else {
                throw new Error('Invalid logic syntax: ' + dumpState(stack));
            }
        };

        search.logicFunc = words => {
            return processTerms(words, terms);
        };
        /* ########################################################################################################################################## */
    }

    if (search.orig != pages['terms']) {
        pages['terms'] = search.orig;
        pages['pages'] = [];
    }
    document.getElementById('pagination').replaceChildren();

    let temp = [];
    let batchesTemp = batches;
    if (search.reverse) {
        batchesTemp = [...batchesTemp].reverse();
    }
    for (let batchInfo of batchesTemp) {
        if (paginator.bail == 0) {
            break;
        }
        let batch = await cacheLoad(batchInfo);
        let itemID = -1;
        let batchTemp = batch;
        if (search.reverse) {
            batchTemp = [...batchTemp].reverse();
        }
        for (let item of batchTemp) {
            itemID++;
            if (paginator.bail == 0) {
                break;
            }

            if (search.before != null) {
                if (item.published >= search.before) {
                    continue;
                }
            }
            if (search.after != null) {
                if (item.published <= search.after) {
                    continue;
                }
            }

            temp = temp.concat(showHit(item, search, false, batchInfo, itemID, paginator, countOnly));
        }
    }
    if (search.show_next) {
        if (paginator.bail == 0) {
            let found = false;
            for (let page of pages['pages']) {
                if (skip == page['skip']) {
                    found = true;
                    if (page['name'] == "Next") {
                        pages['pages'].pop();
                        found = false;
                    }
                }
            }
            if (!found) {
                pages['pages'].push({
                    "name": (pages['pages'].length + 1) + "",
                    "skip": skip,
                });
                pages['pages'].push({
                    "name": "Next",
                    "skip": paginator.pos,
                });
            }
        } else {
            if (pages['pages'].length > 0) {
                if (pages['pages'][pages['pages'].length - 1]['name'] == "Next") {
                    pages['pages'].pop();
                }
            }
            let found = false;
            for (let page of pages['pages']) {
                if (skip == page['skip']) {
                    found = true;
                }
            }
            if (!found) {
                pages['pages'].push({
                    "name": (pages['pages'].length + 1) + "",
                    "skip": skip,
                })
            }
        }
        if (pages['pages'].length > 0) {
            for (let page of pages['pages']) {
                let paginate = document.createElement('button');
                if (page['skip'] == skip) {
                    paginate.className = "page-btn active";
                } else {
                    paginate.className = "page-btn";
                }
                paginate.innerText = page['name'];
                paginate.onclick = () => {
                    window.scrollTo(0, 0);
                    searchFor(search.orig, page['skip']).then();
                };
                document.getElementById('pagination').appendChild(paginate);
            }
        }
    }

    if (countOnly) {
        document.getElementById("totalsCount").innerText = 
            `Found ${paginator.bail == 0 ? 'at least ' : ''}${commafy(paginator.found)} hits in ${commafy(paginator.foundTitles)} episodes`;
    } else {
        if (!search.title) {
            if (paginator.found == 0) {
                let comment = document.getElementById("totalsCount");
                comment.innerText = "(No matches found)";
            } else {
                let comment = document.getElementById("totalsCount");
                comment.innerText = `Found ${paginator.bail == 0 ? 'at least ' : ''}${commafy(paginator.found)} hits in ${commafy(paginator.foundTitles)} episodes`;
                if (paginator.bail == 0) {
                    let keep = document.createElement("span");
                    keep.className = "clickable";
                    keep.innerText = ", produce complete count.";
                    keep.onclick = () => {
                        searchFor(search.orig, 0, true).then();

                    };
                    comment.appendChild(keep);
                }
            }
        }

        document.getElementById("results").replaceChildren(...temp);
    }
}

function commafy(val) {
    return val.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
}

async function showCreation() {
    let info = await getData(0, 0, 100, "json");
    contextAfter = info.after;
    contextBefore = info.before;
    document.getElementById('created').innerHTML = `${info.created} with ${commafy(info.items)} entries`;
    totalItems = info.items;
}

async function cacheWorker(jobs) {
    for (let cur of jobs) {
        let key = cur.join('|');
        if (!(key in batchData)) {
            let data = await getData(...cur);
            batchData[key] = data;
        }
    }
}

function cacheData(workers) {
    (async () => {
        const newInfo = await getData(0, 0, 100, "json");
        const newBatches = await getData(...newInfo.data);
        info = newInfo;
        batches = newBatches;
        const jobs = Array.from({ length: workers }, () => []);
        let curWorker = 0;
        for (let i = 0; i < batches.length; i++) {
            jobs[curWorker].push(batches[i]);
            curWorker = (curWorker + 1) % workers;
        }
        jobs[curWorker].push(['lemma', 0, 0]);
        curWorker = (curWorker + 1) % workers;
        for (let cur of jobs) {
            cacheWorker(cur);
        }
    })();
}

document.addEventListener("DOMContentLoaded", function(event) {
    function enableSimilar() {
        const box = document.getElementById('similar');
        box.disabled = !(document.getElementById('search_type').value === 'raw');
        if (box.disabled) {
            box.checked = false;
        }
    }
    document.getElementById('search_type').addEventListener('change', enableSimilar);
    enableSimilar();

    if (window.location.hash.substring(1, 5) == "rid=") {
        let temp = document.getElementById("info");
        if (temp != null) {
            temp.src = temp.src.replace(".png", "-rid.png");
        }
    }

    document.getElementById("show_all").addEventListener('click', e => {
        e.preventDefault();
        searchFor("", 0, false, false, true).then();
    });

    document.getElementById("show_latest").addEventListener('click', e => {
        e.preventDefault();
        searchFor("", 0, false, true, false).then();
    });

    let info = window.location.hash.substring(1);
    info = info.split(",");
    if (info.length == 4 || info.length == 5) {
        document.getElementById("search-card").style.display = 'none';
        document.getElementById("results-header").style.display = 'none';
        document.getElementById("footer").style.display = 'none';
        showTranscript(parseInt(info[0]), parseInt(info[1]), parseInt(info[2]), parseInt(info[3])).then(() => {
            if (info.length == 5) {
                let at = parseInt(info[4]);
                for (let cur of document.getElementsByTagName("span")) {
                    if (cur.at >= at) {
                        cur.scrollIntoView();
                        break;
                    }
                }
            }
        });
    } else {
        showCreation().then(() => {
            document.getElementById("search").focus();
            cacheData(4);
        });
    }

    document.querySelectorAll('.page-btn').forEach(button => {
        button.addEventListener('click', () => {
            document.querySelector('.page-btn.active').classList.remove('active');
            button.classList.add('active');
        });
    });

    document.querySelector('form').addEventListener('submit', (e) => {
        e.preventDefault();
        let val = document.getElementById("search").value;
        if (val.length > 0) {
            document.getElementById("search").blur();
            searchFor(val).then().catch(e => {
                notify("ERROR: " + e);
            });
        }
    });
});
</script>
</head>
<body>
<div class="container">
    <div class="page-title" id="page-title">
        <div class="title-text">
            <p><!-- search_header --></p>
        </div>
    </div>
    <div class="search-card" id="search-card">
        <form class="search-form">
            <div class="search-bar">
                <select aria-label="Search style" id="search_type" class="search-style">
                    <option value="raw">Use this exact string:</option>
                    <option value="regex">Use regular expressions:</option>
                    <option value="logic">Use logic ops (AND, OR, NOT, NEAR, WHOLE):</option>
                    <option value="title">Use titles only:</option>
                </select>
                <input id="search" type="text" placeholder="Enter your search query..." aria-label="Search query" autocomplete="off" spellcheck="false" autocorrect="off">
                <button type="submit">Search</button>
            </div>
            
            <div class="search-options">
                <div class="option-group">
                    <label class="option-label">Time Range</label>
                    <div class="time-inputs">
                        <div class="time-input">
                            <input id="start" type="text" placeholder="Start date" aria-label="Start date">
                        </div>
                        <div class="time-input">
                            <input id="end" type="text" placeholder="End date" aria-label="End date">
                        </div>
                    </div>
                </div>

                <!-- search_terms -->
                
                <div class="option-group">
                    <label class="option-label">Options</label>
                    <div class="checkbox-group">
                        <input type="checkbox" id="reverse" aria-label="Results start with newest first">
                        <label for="reverse">Results start with newest first</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="similar" aria-label="Include similar words">
                        <label for="similar">Include similar words</label>
                    </div>
                </div>
            </div>

            <div class="quick-links">
                <a href="#" class="quick-link" id="show_all">Show all episodes</a>
                <a href="#" class="quick-link" id="show_latest">Show latest episodes</a>
            </div>
        </form>
    </div>
    
    <div class="results-container">
        <div class="results-header" id="results-header">
            <div class="result-stats" id="totalsCount">...</div>
        </div>
        
        <div class="results-list" id="results"></div>

        <div class="pagination" id="pagination"></div>
        
        <div class="created" id="footer">
            Created: <span id="created">(loading)</span>
        </div>
        <div class="created">
            This search page is created by a third party, not affiliated to the creators of the podcast.
        </div>
        <!-- example_link -->
    </div>
</div>
    
</body>
</html>
